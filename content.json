[{"title":"Webpack 记录","date":"2021-08-19T08:56:15.000Z","path":"2021/08/19/20210819/","text":"Webpack 配置项记录，以后新建工程很快 entry entry 是描述一个 bundle 的入口文件是什么。在具体在业务中使用的方式有如下三种： 直接在 package.json 中描述 entry 内容； 动态创建 entry 内容，使用 glob 等工具使用若干通配符，运行时获得 entry 的条目，这种方式比较适合入口文件不集中且较多的场景； 根据 entry 内容挂钩一些 html 模板 loader，例如 html-webpack-plugin，ejs-html-loader 等，这种方式主要用以解决 html 随模板生成，但同时根据 entry 的一些内容自动替换模板中一些关键字。output output 的作用在于告知 webpack 该如何把构建编译后的文件放入到磁盘。在具体业务中使用的方式有如下种： output.filename: 修改构建后文件的命名，业务中会存在 4 种情况。 直接设置一个 bundle 的 name，例如 index.bundle.js 这类场景发生在只有一个 entry 的情况； [name]，使用 Chunk 的名称 [hash]，使用 Compilation 的 hash 值，在这种方式下生成的资源文件会都有相同的 hash 值 [chunkhash]，使用 Chunk 的 hash 值，在这种方式下会根据每个 Chunk 的来生成 hash 值，使用这种方式的情况发生在想要 cache，cache 会衍生出很多的内容这个在之后再做展开。 output.path: 修建构建后文件输出到磁盘的目录，业务中会存在 1 种情况。 传入一个相对于当前 cwd 的路径，这种自定义情况非常普遍 output.publicPath: 申明构建后的资源文件的引入地址，业务中会存在 1 种情况 设置为 https://xxxx.xx.com/assets/ 这种方式，这种方式的出现在于 webpack 默认在引用资源时都是从根目录开始，然后现实中 assets 资源 和 html 会随不同的发布平台发布。 output.chunkFilename：声明非 entry chunks 的资源文件的命名，一般它发生的场景在 code split 即按需加载的业务场景，例如 require.ensure，在这种场景下，会对 require.ensure 的模块进行独立的打包，文件命名也会有四种情况。 [id]，id 值 从 0 开始 [name]，该 chunk 的 name，require.ensure(dependencies: String[], callback: function(require), errorCallback: function(error), chunkName: String) [hash]，使用 Compilation 的 hash 值，在这种方式下生成的资源文件会都有相同的 hash 值 [chunkhash]，使用 Chunk 的 hash 值，在这种方式下会根据每个 Chunk 的来生成 hash 值，使用这种方式的情况发生在想要 cache，cache 会衍生出很多的内容这个在之后再做展开。 output.library：一旦设置后该 bundle 将被处理为 library。 output.libraryTarget：export 的 library 的规范，有支持 var, this, commonjs,commonjs2,amd,umd。resolve resolve.alias：为模块设置别名。这种方案通常使用在两种情况下： 一种是单纯为模块设置别名，一来方便自己不再需要根据目录书写 ..&#x2F; 等这种路径操作，另外也可以提升 webpack 在 resolve 模块时的速度； 另外一种则和优化上扯上一些关系，比如 resolve.alias.a &#x3D; isTest ? ‘moduleTestA’ : ‘moduleA’，如上这种方式使用最大的好处在于能根据当前所属代码所需情况构建产物中只会有 moduleTestA 或者 moduleA。以上这种方式可以在所有资源文件应用。当然也可以使用 babel-plugin-module-resolver 和 less-plugin-rewrite-import 予以解决。 resolve.root：添加个人目录到 webpack 查找模块的路径里，这种需求比如发生在当前某个项目所依赖某个文件并不在该项目中。 resolve.modulesDirectories：模块解析方式，在项目中我看到一般会有两种使用的场景，_ 一种主要针对开发者，需要新增一种模块的解析方式。比如设置为 [“node_modules”, “bower_components”] 那么在项目中 foo&#x2F;bar 的文件下依赖一个模块 a, 那么 webpack 会通过如下的顺序去寻找依赖foo&#x2F;bar&#x2F;node_modules&#x2F;afoo&#x2F;bar&#x2F;bower_components&#x2F;afoo&#x2F;node_modules&#x2F;afoo&#x2F;bower_components&#x2F;anode_modules&#x2F;abower_components&#x2F;a_ 另外一种则是想要申明模块 resolve 的优先级，比如在一个项目中有依赖 A，B，依赖的 A,B 同时依赖了 C，如果在构建过程中，你想明确表示我只想要某个 C 的话，则就可以通过这种方式。 resolve.extensions：设置解析模块的拓展名。默认为 [“”, “.webpack.js”, “.web.js”, “.js”]。比如新增一种文件扩展名，[“”, “.webpack.js”, “.web.js”, “.web.ts”, “.web.tsx”, “.js”] resolve.packageMains：设置 main 的入口文件。这种方式目前会在 webpack@2 中使用 resolve.mainFields 来解决 tree-shaking，目前支持的有 redux 等。resolveLoader resolveLoader.modulesDirectories：同 resolve.modulesDirectories 只不过针对 loader，这边需要注意的是在 resolve.modulesDirectories 中关于优先级的，在工具被二次封装时会用到比较多。 resolveLoader.moduleTemplates： [“-webpack-loader”, “-web-loader”, “-loader”, ““]webpack@1 中内置的模板，但是在 webpack@2 是并不会补齐。resolve.root, resolve.fallback, resolve.modulesDirectories 这三个属性在 webpack@2 中被合并到了 resolve.modulesmodule module.loaders：对应模块的加载器。在 webpack@2 中使用 module.rules 予以取代。以下会罗列目前常用文件类型的模块加载处理方式。 babel-loader 处理 .js 和 .jsx 文件，由于历史原因 atool-build 在处理 .jsx 文件时会处理 node_modules 下内容。 目前 atool-build 已经内置的 preset 有 babel-preset-es2015-ie，babel-preset-react，babel-preset-stage-0，plugins 有 babel-plugin-add-module-exports 和 babel-plugin-transform-decorators-legacy。 目前业务中自行使用的有: plugins: babel-plugin-import 构建资源大小提供优化，babel-plugin-transform-runtime 实现按需加载 pollyfill 需要与 babel-runtime 结合使用，babel-plugin-module-resolver 实现诸如 webpack 中 resolve.alias 功能，babel-plugin-dva-hmr 和 babel-plugin-dev-expression 实现 dva hot module replacement 功能，babel-plugin-react-intl 实现 react 多语言方案， babel-plugin-es6-promise 覆盖原有 promise; preset: babel-preset-env 实现根据浏览器支持情况自动打包 pollyfill 等功能，babel-preset-es2016 等。在实际过程中，都可能需要对 preset 传入参数的需求。一般设置如下 presets: [[require.resolve(‘xxx-preset’), { options: hi }]] cacheDirectory：缓存支持，一般默认就开启 babelrc：一般需要禁用掉，防止用户端的 babel 配置影响内置配置 tsx-loader: 处理 ts 文件，内置参数 target: ‘es6’, jsx: ‘preserve’,moduleResolution: ‘node’, declaration: false, sourceMap: true，需要注意的是在使用 ts 项目时必须要人为引入一个 ts config.json 的文件，如果没有内容，内部设置为一个空对象即可。 style-loader: 通过 js 方式 inject style 节点来注入样式，一般用于开发环境 css-loader: 处理 css 文件，一般现有项目中都会使用 ExtractTextPlugin 把样式文件抽取出来，但是在本地开发环境下一般不会 extract 出来，因为一旦 extract 出来会导致 hmr 对样式失效。所以一般在开环环境下会 style-loader!css-loader!postcss-loader 而在 production 下采用 ExtractTextPlugin，另外在每个 loader 都有对应的参数，postcss 还有专门的插件集。除此之外，常用的 css-loader 参数有 modules autoprefix indentName 等 postcss-loader: 目前在 postcss 中内置的 plugin 有 rucksack-css - 可废弃 和 autoprefixer 用以实现 autoprefix。一般针对适配的不同的浏览器，需要对 autoprefixer 配置 browsers 参数。一般在无线业务中为了适配高清方案也会引入 postcss-plugin-pxtorem, 同时也需要设置一些参数。 less-loader: 处理 less 文件，一般情况下需要配置 modifyVars 参数，用以覆盖 less 变量值 sass-loader: 处理 sass 文件，也有使用 fast-sass-loader 和 @ali&#x2F;sass-loader file-loader: 处理 html 文件，当前 atool-build 内置的方式，在实际业务中，很多并不希望 html 是拍平的结构，所以他们会自定义 fileloader 的参数，比如 file?name&#x3D;[path][name].[ext]&amp;context&#x3D;.&#x2F;src&#x2F;pages，但是也有不少业务中对 html 处理引入了新的 loader, 有 ejs-html-loader，html-minify-loader，还有直接使用插件 HtmlWebpackPlugin 来处理的情况，经过研究，根本上其实是想要解决 html 的自动化生成，以及内部资源文件的引用可以自动化生成。 url-loader: 处理 woff woff2 ttf eot svg png jpg jpeg gif 文件，目前业务中会有变更的点有，需要设置 limit 的大小，以及 svg 的处理可能需要存在多个 loader 处理，因为在使用 antd-mobile 业务中需要新增一个 svg-sprite-loader 来把 svg 文件当成一个 component svg-sprite-loader, 已在 url-loader 中予以说明 HtmlWebpackPlugin, 已在 file-loader 中予以说明 ejs-html-loader, 已在 file-loader 中予以说明 html-minify-loader, 已在 file-loader 中予以说明 handlebars-loader, 处理 .handlebars 文件，并未内置，业务中自行引入 aptl-loader, 处理 .atpl 文件 raw-loader, 处理 tpl 文件，也有使用 html-loader 来处理的 scss-loader, 处理 scss 文件 vue-loader, 处理 vue 文件 json-loader, 处理 json 文件 注：一个正常 loader 的配置可能需要配置 test,exclude,include,loader,loaders 属性 module.preLoaders：istanbul-instrumenter，此方式在 webpack@2 中被弃用，可以直接在对应的应用规则的文件中启用 enforce: ‘pre’ module.postLoaders：es3ify-loader，提升 ie 兼容性，此方式在 webpack@2 中被弃用，可以直接在对应的应用规则的文件中启用 enforce: ‘post’ module.noParse: 指明 webpack 不去解析某些内容，该方式有助于提升 webpack 的构建性能，配置内容可以是externals 目前业务中使用都为声明外部依赖，这种方式有益于加速 webpack 构建，但是需要开发者额外引入被 external 库的 cdn 地址，常见的有 React 和 ReactDom。devtool 文档node 目前内置如下内容为 empty[‘child_process’,‘cluster’,‘dgram’,‘dns’,‘fs’,‘module’,‘net’,‘readline’,‘repl’,‘tls’,];plugin - webpack 内置 大部分插件都有需要参数传入 webpack.optimize.CommonsChunkPlugin，在业务中通常有两种使用方式，一种是直接从所有的代码中抽取 common 的逻辑，此处可以配置 common 抽取最小单元，还有一种 common 的使用方式是 vendor 即用户配置具体的 entry 条目，并把该条目抽取为 vendor。 webpack.optimize.OccurenceOrderPlugin：优化插件，优化 module id webpack.optimize.UglifyJsPlugin：代码丑化 webpack.optimize.DedupePlugin：打包时删除重复模块代码 webpack.DefinePlugin：给代码注入全局标识符 webpack.BannerPlugin：给代码添加 banner 信息 webpack.ProvidePlugin：调用模块的别名 webpack.NoErrorsPlugin：报错但不退出 webpack 进程 webpack.ProgressPlugin：显示构建进度 DllPlugin：主要业务中应用于提升本地调试速度，配置需要有单独的 Dll 配置文件 DllReferencePlugin：主要业务中应用于提升本地调试速度，需要配合 DllPlugin 使用plugin - webpack 扩展 大部分插件都有需要参数传入 webpack-visualizer-plugin：查看构建 bundle 的构成 html-webpack-plugin：生成 html 文件 copy-webpack-plugin：拷贝文件或者文件夹 clean-webpack-plugin：清理文件或者文件夹 i18n-webpack-plugin：国际化支持 webpack-shell-plugin：给 shell 提供运行时机 case-sensitive-paths-webpack-plugin： 路径大小写敏感问题 friendly-errors-webpack-plugin：友好报错信息 extract-text-webpack-plugin：将文本内容生成抽取成独立文件 happypack：加速构建，需要对配置做比较大改动 parallel-webpack： 提供资源文件的并发构建 map-json-webpack-plugin：使用 hash 时，生成资源映射文件需要沉淀的方案 html 自动化生成，自动更新引用资源 更加优质的 common 生成逻辑 目前有持久化缓存需求，需要给出一个更加完善的方案，即更加合理化的 hash 方案 https://github.com/goldhand/sw-precache-webpack-plugin 通过 sw 来完成资源文件离线化 单一文件多种 loader 处理，单一文件多种 loader 如何进行区间调整","categories":[{"name":"Font-end","slug":"Font-end","permalink":"https://jiangjingscom.github.io/categories/Font-end/"}],"tags":[{"name":"FontEnd","slug":"FontEnd","permalink":"https://jiangjingscom.github.io/tags/FontEnd/"}]},{"title":"Webpack 配置项","date":"2021-08-10T07:56:15.000Z","path":"2021/08/10/20210810/","text":"Webpack 记录，各种反复压缩操作，以后不要再来一遍了。 注意把项目结构留一留。 配置分析：模块打包器，构建依赖关系图，打包成一个或多个 bundle。 entry：入口。单入口或多入口、第三方库入口。 output：输出目录及命名。 loader：模块解析,在 module 中配置 rules。处理非 js 文件，将所有类型的文件转换为 webpack 能够处理的有效模块。 mode：development&#x2F;production。 plugins：打包、优化、压缩等等等等。webpack 内置模块： webpack.optimize.OccurenceOrderPlugin：优化插件，优化 module id webpack.optimize.DedupePlugin：有些 JS 库有自己的依赖树，并且这些库可能有交叉依赖，DedupePlugin 可以找到他们删除重复依赖 webpack.optimize.UglifyJsPlugin：代码丑化 webpack.DefinePlugin：给代码注入全局标识符 webpack.BannerPlugin：给代码添加 banner 信息 webpack.ProvidePlugin：调用模块的别名 webpack.NoErrorsPlugin：报错但不退出 webpack 进程 webpack.ProgressPlugin：显示构建进度其他常见模块： ：查看构建 bundle 的构成 html-webpack-plugin：生成 html 文件 copy-webpack-plugin：拷贝文件或者文件夹 clean-webpack-plugin：清理文件或者文件夹(rimraf 模块) webpack-shell-plugin：给 shell 提供运行时机 case-sensitive-paths-webpack-plugin： 路径大小写敏感问题 friendly-errors-webpack-plugin：友好报错信息 extract-text-webpack-plugin：将文本内容生成抽取成独立文件使用 webpack 的站点中有三种代码类型： 自己编写的源码 依赖的第三方 libary 或 vender 代码 webpack 的 runtime 和 manifest：runtime 根据 manifest 中的映射数据来查询和解析模块runtime 包含：浏览器运行时，webpack 用来连接模块化的应用程序的所有代码。在模块交互时，连接模块所需的加载和解析逻辑。包括浏览器中的已加载模块的连接，以及懒加载模块的执行逻辑。manifest：当编译器(compiler)开始执行、解析和映射应用程序时，它会保留所有模块的详细要点。 构建流程： 解析 webpack 配置参数，合并 shell 传入和 webpack.config.js 文件里配置的参数，生成最后的配置结果 注册所有配置的插件，让插件监听 webpac 构建生命周期的事件节点，以便做出对应的反应 从配置的 entry 入口文件开始解析文件构建 AST 语法树，找出每个文件所依赖的文件，递归下去 在解析文件 递归的过程中根据文件类型和 loader 配置找出合适的 laoder 用来对文件进行转换 递归完后得到每个文件的最终结果，根据 entry 配置生成代码块 chunk 输出所有 chunk 到文件系统 缓存要点:1、合理划分模块。在 entry 入口中，制定 vender、libs 等。 代码分割，一般引入第三方库更新频率低，利于缓存 2、提取频繁共用的公共模块。利用 commonsChunkPlugin 将公共的模块抽离出来，生成一个或多个依赖文件。通过 minchucks 指定最少依赖次数(为 infinity 表示不包含任何模块)。(在多页面&#x2F;多入口很有优势，单入口无法抽离文件中的公共模块) 频繁模块的抽离，压缩代码体积3、抽离清单。一般 manifest 打包在 vender 文件中,在 commonsChunkPlugin 中的 names 中增加 manifest（放在 libs 之前，可用其他名字代替）可以抽离出 manifest。为了减少请求，也可以使用 inline-manifest-webpack-plugin 配合 html-webpack-plugin 内联至 html 中 如果 webpack 打包生成的 hash 变了之后，manifest 会改变，则 vender 也会变化，而 vender 通常比较大。因此需要分离 manifest。左图使用修改 booking.vue 前，右图修改 booking.vue 后 使用 inline-manifest-webpack-plugin 写入 html 后 4、稳定的 chunk id（webpack 内部对文件的引用）。默认的 chunk id 是 webpack 根据依赖的收集顺序递增的正整数。当修改 app 或者增删文件时，chunk id 会变化导致许多模块（文件的 chunckhash 没有变化而 id 变了）的缓存不能使用，manifest（webpack 的 runtime 中包含 chunk id 及其对应的 chunckhash 对象）也改变了，我们需要 chunk id 最好稳定。1）OccurrenceOrderPlugin：让 webpack 以依赖模块出现的次数决定 id 的值，次数越多 id 越小。缺点：但依赖变动大，chunk id 会大幅变动。2）NamedModulesPlugin：将 chunk id 替换为相对路径。缺点：文件增大+filename 导致安全问题3）HashedModuleIdsPlugin：NamedModulesPlugin 进阶，将路径进行 MD5 摘要。左图使用 HashedModuleIdsPlugin 前，右图使用 HashedModuleIdsPlugin 后，booking.vue page 5、稳定的 hash 值。 【hash】：在 webpack 构建中会产生一个 compilation 对象，hash 是对该对象内的所有内容计算而来。当使用了 extract 时，由于其抽取的异步流程，有时即使没有改动，也会存在 hash 异动情况。 【chunkhash】：每一个 chunkhash 都根据自身的内容计算而来。 1）webpack-md5-hash：使 chunkhash 与该 chunk 内的代码相关联，让 chunck 与其依赖的 chunk id 无关（子改变与父无关）。缺点：当修改 app 时，app 的 chunk id 改变，因此 vender 中对应的 app 模块的 ID 改变，所以 vender 的 hash 理应改变（这时子与父有关）。但是由于 vender 实际包含模块没变，webpack-md5-hash 根据 chunk 内实际包含的模块生成的 chunckhash，因此 vender 的 hash 不会变，导致引入的 vender 是旧的。2）webpack-chunk-hash 6、其他资源缓存 Image&#x2F;Fonts 的【hash】由 webpack&#x2F;file-loader 计算。 提取 CSS(写在 js 中的 style 里的样式无法被抽离，仍打包在 js 中)的【contenthash】由 webpack&#x2F;extract-text-webpack-plugin 计算。 其他问题： 无法抽离单入口多路由页面的公共模块组件，可以自己指定写死。 在不同的电脑下 chunkhash change module 的版本问题","categories":[{"name":"Font-end","slug":"Font-end","permalink":"https://jiangjingscom.github.io/categories/Font-end/"}],"tags":[{"name":"FontEnd","slug":"FontEnd","permalink":"https://jiangjingscom.github.io/tags/FontEnd/"}]},{"title":"同步加载与异步加载","date":"2021-07-23T15:56:15.000Z","path":"2021/07/23/20210723/","text":"很长很长，属于看完就忘类型。有需要再看。 一、同步加载与异步加载的形式 同步加载我们平时最常使用的就是这种同步加载形式： 1&lt;script src=&quot;http://yourdomain.com/script.js&quot;&gt;&lt;/script&gt; 同步模式，又称阻塞模式，会阻止浏览器的后续处理，停止了后续的解析，因此停止了后续的文件加载（如图像）、渲染、代码执行。 js 之所以要同步执行，是因为 js 中可能有输出 document 内容、修改dom、重定向等行为，所以默认同步执行才是安全的。 以前的一般建议是把 script 放在页面末尾 body 之前，这样尽可能减少这种阻塞行为，而先让页面展示出来。 简单说：加载的网络 timeline 是瀑布模型，而异步加载的 timeline 是并发模型。 常见异步加载（Script DOM Element） 12345678(function () &#123; var s = document.createElement(&quot;script&quot;); s.type = &quot;text/javascript&quot;; s.async = true; s.src = &quot;http://yourdomain.com/script.js&quot;; var x = document.getElementsByTagName(&quot;script&quot;)[0]; x.parentNode.insertBefore(s, x);&#125;)(); 异步加载又叫非阻塞，浏览器在下载执行 js 同时，还会继续进行后续页面的处理。 这种方法是在页面中 script 标签内，用 js 创建一个 script 元素并插入到 document 中。 这样就做到了非阻塞的下载 js 代码。 async 属性是 HTML5 中新增的异步支持，见后文解释，加上好（不加也不影响）。此方法被称为 Script DOM Element 法，不要求 js 同源。 将 js 代码包裹在匿名函数中并立即执行的方式是为了保护变量名泄露到外部可见，这是很常见的方式，尤其是在 js 库中被普遍使用。 例如 Google Analytics 和 Google+ Badge 都使用了这种异步加载代码： 1234567891011121314151617(function () &#123; var ga = document.createElement(&quot;script&quot;); ga.type = &quot;text/javascript&quot;; ga.async = true; ga.src = &quot;https:&quot; == document.location.protocol ? &quot;https://ssl&quot; : &quot;http://www&quot;; var s = document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(ga, s);&#125;)();(function () &#123; var po = document.createElement(&quot;script&quot;); po.type = &quot;text/javascript&quot;; po.async = true; po.src = &quot;https://apis.google.com/js/plusone.js&quot;; var s = document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(po, s);&#125;)(); 但是，这种加载方式在加载执行完之前会阻止 onload 事件的触发，而现在很多页面的代码都在 onload 时还要执行额外的渲染工作等，所以还是会阻塞部分页面的初始化处理。 onload 时的异步加载 123456789101112(function () &#123; function async_load() &#123; var s = document.createElement(&quot;script&quot;); s.type = &quot;text/javascript&quot;; s.async = true; s.src = &quot;http://yourdomain.com/script.js&quot;; var x = document.getElementsByTagName(&quot;script&quot;)[0]; x.parentNode.insertBefore(s, x); &#125; if (window.attachEvent) window.attachEvent(&quot;onload&quot;, async_load); else window.addEventListener(&quot;load&quot;, async_load, false);&#125;)(); 这和前面的方式差不多，但关键是它不是立即开始异步加载 js ，而是在 onload 时才开始异步加载。这样就解决了阻塞 onload 事件触发的问题。 补充：DOMContentLoaded 与 OnLoad 事件 DOMContentLoaded : 页面(document)已经解析完成，页面中的 dom 元素已经可用。但是页面中引用的图片、subframe 可能还没有加载完。OnLoad：页面的所有资源都加载完毕（包括图片）。浏览器的载入进度在这时才停止。这两个时间点将页面加载的 timeline 分成了三个阶段。 异步加载的其它方法由于 Javascript 的动态特性，还有很多异步加载方法： XHR Eval XHR Injection Script in Iframe Script Defer document.write Script Tag 还有一种方法是用 setTimeout 延迟 0 秒 与 其它方法组合。XHR Eval ：通过 ajax 获取 js 的内容，然后 eval 执行。 1234567891011121314var xhrObj = getXHRObject();xhrObj.onreadystatechange = function() &#123; if ( xhrObj.readyState != 4 ) return;eval(xhrObj.responseText);&#125;;xhrObj.open(&#x27;GET&#x27;, &#x27;A.js&#x27;, true);xhrObj.send(&#x27;&#x27;);Script in Iframe：创建并插入一个 iframe 元素，让其异步执行 js 。var iframe = document.createElement(&#x27;iframe&#x27;);document.body.appendChild(iframe);var doc = iframe.contentWindow.document;doc.open().write(&#x27;&lt;body onload=&quot;insertJS()&quot;&gt;&#x27;);doc.close(); GMail Mobile：页内 js 的内容被注释，所以不会执行，然后在需要的时候，获取 script 元素中 text 内容，去掉注释后 eval 执行。 12345&lt;script type=&quot;text/javascript&quot;&gt; /* var ... */&lt;/script&gt; 详见参考资料中 2010 年的 Velocity 大会 Steve Souders 和淘宝的那两个讲义。 二、async 和 defer 属性 defer 属性 1&lt;script src=&quot;file.js&quot; defer&gt;&lt;/script&gt; defer 属性声明这个脚本中将不会有 document.write 或 dom 修改。浏览器将会并行下载 file.js 和其它有 defer 属性的script，而不会阻塞页面后续处理。 defer 属性在 IE 4.0 中就实现了，超过 13年了！Firefox 从 3.5 开始支持 defer 属性 。 注：所有的 defer脚本保证是按顺序依次执行的。 async 属性 1&lt;script src=&quot;file.js&quot; async&gt;&lt;/script&gt; async 属性是 HTML5 新增的。作用和 defer类似，但是它将在下载后尽快执行，不能保证脚本会按顺序执行。它们将在 onload事件之前完成。 Firefox 3.6、Opera 10.5、IE 9 和 最新的 Chrome 和 Safari 都支持async 属性。可以同时使用 async 和 defer，这样 IE 4 之后的所有 IE都支持异步加载。 详细解释 script 标签在 HTML 4.01 与 HTML5 的区别： type属性在 HTML 4 中是必须的，在 HTML5 中是可选的。 async 属性是 HTML5 中新增的。 个别属性（xml:space）在 HTML5 中不支持。 说明：（1） 没有 async 属性，script 将立即获取（下载）并执行，然后才继续后面的处理，这期间阻塞了浏览器的后续处理。 （2） 如果有 async 属性，那么 script 将被异步下载并执行，同时浏览器继续后续的处理。 （3） HTML4 中就有了 defer 属性，它提示浏览器这个 script 不会产生任何文档元素（没有 document.write），因此浏览器会继续后续处理和渲染。 （4） 如果没有 async 属性但是有 defer 属性，那么 script 将在页面 parse 之后执行。 （5）如果同时设置了二者，那么 defer 属性主要是为了让不支持 async属性的老浏览器按照原来的 defer 方式处理，而不是同步方式。 另参见官方说明：script async 个人补充： 既然 HTML5 中已经支持异步加载，为什么还要使用前面推荐的那种麻烦（动态创建 script 元素）的方式？ 答：为了兼容尚不支持 async 老浏览器。如果将来所有浏览器都支持了，那么直接在 script 中加上 async属性是最简单的方式。 三、延迟加载（lazy loading） 前面解决了异步加载（asyncloading）问题，再谈谈什么是延迟加载。 延迟加载：有些 js 代码并不是页面初始化的时候就立刻需要的，而稍后的某些情况才需要的。延迟加载就是一开始并不加载这些暂时不用的 js，而是在需要的时候或稍后再通过 js 的控制来异步加载。也就是将 js 切分成许多模块，页面初始化时只加载需要立即执行的 js ，然后其它 js 的加载延迟到第一次需要用到的时候再加载。 特别是页面有大量不同的模块组成，很多可能暂时不用或根本就没用到。就像图片的延迟加载，在图片出现在可视区域内时（在滚动条下拉）才加载显示图片。 四、script 的两阶段加载 与 延迟执行（lazy execution） JS 的加载其实是由两阶段组成：下载内容（download bytes）和执行（parse andexecute）。 浏览器在下载完 js 的内容后就会立即对其解析和执行，不管是同步加载还是异步加载。 前面说的异步加载，解决的只是下载阶段的问题，但代码在下载后会立即执行。 而浏览器在解析执行 JS 阶段是阻塞任何操作的，这时的浏览器处于无响应状态。 我们都知道通过网络下载 script 需要明显的时间，但容易忽略了第二阶段，解析和执行也是需要时间的。 script 的解析和执行所花的时间比我们想象的要多，尤其是 script 很多很大的时候。有些是需要立刻执行，而有些则不需要（比如只是在展示某个界面或执行某个操作时才需要）。 这些 script 可以延迟执行，先异步下载缓存起来，但不立即执行，而是在第一次需要的时候执行一次。 利用特殊的技巧可以做到 下载 与 执行的分离 (再次感谢 javascript 的动态特性)。 比如将 JS 的内容作为 Image 或 object 对象加载缓存起来，所以就不会立即执行了，然后在第一次需要的时候再执行。 此部分的更多解释 请查看末尾参考资料中 ControlJS 的相关链接。 小技巧： 模拟较长的下载时间： 写个后端脚本，让其 sleep 一定时间。如在 jsp 中Thread.sleep(5000); ，这样 5 秒后才能收到内容。 模拟较长的 js代码执行时间（因为这步一般比较快不容易观察到）： var t_start &#x3D; Number(newDate()); while ( t_start + 5000 &gt; Number(new Date()) ) {} 这个代码将使 js 执行 5秒才能完成！ 五、script 标签使用的历史 script 放在 HEAD 中 123&lt;head&gt; &lt;script src=&quot;“…”&quot;&gt;&lt;/script&gt;&lt;/head&gt; 阻止了后续的下载； - 在 IE 6-7 中 script 是顺序下载的，而不是现在的“并行下载、顺序执行” 的方式； - 在下载和解析执行阶段阻止渲染（rendering）； script 放在页面底部（2007） 123&lt;body&gt; &lt;script src=&quot;“…”&quot;&gt;&lt;/script&gt;&lt;/body&gt; 不阻止其它下载； _ 在 IE 6-7 中 script 是顺序下载的； _在下载和解析执行阶段阻止渲染（rendering）； 异步加载 script（2009） 123var se = document.createElement(&quot;script&quot;);se.src = &quot;http://anydomain.com/A.js&quot;;document.getElementsByTagName(&quot;head&quot;)[0].appendChild(se); 这就是本文主要说的方式。 不阻止其它下载； 在所有浏览器中，script 都是并行下载； 只在解析执行阶段阻止渲染（rendering）； 异步下载 + 按需执行 (2010) 123var se = new Image();se.onload = registerScript();se.src = &quot;http://anydomain.com/A.js&quot;; 把下载 js 与解析执行 js 分离出来 不阻止其它下载； 在所有浏览器中，script 都是并行下载； 不阻止渲染（rendering）直到真正需要时； 六、异步加载的问题 在异步加载的时候，无法使用 document.write 输出文档内容。 在同步模式下，document.write 是在当前 script 所在的位置输出文档的。而在异步模式下，浏览器继续处理后续页面内容，根本无法确定 document.write 应该输出到什么位置，所以异步模式下 document.write 不可行。 而到了页面已经 onload 之后，再执行 document.write 将导致当前页面的内容被清空，因为它会自动触发 document.open 方法。 实际上 document.write 的名声并不好，最好少用。 替代方法： 虽然异步加载不能用 document.write，但还是可以 onload 之后执行操作 dom（创建 dom 或修改 dom）的，这样可以实现一些自己的动态输出。比如要在页面异步创建一个浮动元素，这和它在页面中的位置就没关系了，只要创建出该 dom 元素添加到 document 中即可。 如果需要在固定位置异步生成元素的内容，那么可以在该固定位置设置一个 dom 元素作为目标，这样就知道位置了，异步加载之后就可以对这个元素进行修改。 七、JS 模块化管理 异步加载，需要将所有 js 内容按模块化的方式来切分组织，其中就存在依赖关系，而异步加载不保证执行顺序。 另外，namespace 如何管理 等相关问题。这部分已超出本文内容，可参考：RequireJS 、CommonJS 以及 王保平(淘宝)的 SeaJS 及其博客 。 七、JS 最佳实践 最小化 js 文件，利用压缩工具将其最小化，同时开启 http gzip 压缩。工具： 尽量不要放在 head 中，尽量放在页面底部，最好是 body 之前的位置 避免使用 document.write 方法 异步加载 js ，使用非阻塞方式，就是此文内容。 尽量不直接在页面元素上使用 Inline Javascript，如 onClick 。有利于统一维护和缓存处理。","categories":[{"name":"Font-end","slug":"Font-end","permalink":"https://jiangjingscom.github.io/categories/Font-end/"}],"tags":[{"name":"FontEnd","slug":"FontEnd","permalink":"https://jiangjingscom.github.io/tags/FontEnd/"}]},{"title":"关于模块化的一些知识点","date":"2021-06-29T12:56:15.000Z","path":"2021/06/29/20210629/","text":"关于模块化的一些知识点，以前收录的一些文档 AMD 规范文档 https://github.com/amdjs/amdjs-api/wiki/AMDamdjs 的 require 接口文档 https://github.com/amdjs/amdjs-api/wiki/requireamdjs 的接口文档 https://github.com/amdjs/amdjs-api/wikiRequireJS 官网接口文档 http://www.requirejs.org/docs/api.html 模块系统 https://github.com/seajs/seajs/issues/240前端模块化开发的价值 https://github.com/seajs/seajs/issues/547前端模块化开发那点历史 https://github.com/seajs/seajs/issues/588CMD 模块定义规范 https://github.com/seajs/seajs/issues/242SeaJS API 快速参考 https://github.com/seajs/seajs/issues/266从 CommonJS 到 Sea.js https://github.com/seajs/seajs/issues/269 RequireJS 和 AMD 规范 http://javascript.ruanyifeng.com/tool/requirejs.htmlCommonJS 规范 http://javascript.ruanyifeng.com/nodejs/commonjs.htmlJavascript 模块化编程 http://www.ruanyifeng.com/blog/2012/10/javascript_module.htmlJavascript 模块化编程 http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html 知乎 AMD 和 CMD 的区别有哪些？ http://www.zhihu.com/question/20351507 JavaScript 模块化开发 - CommonJS 规范 http://www.feeldesignstudio.com/2013/09/javascript-module-pattern-commonjsJavaScript 模块化开发 - AMD 规范 http://www.feeldesignstudio.com/2013/09/javascript-module-pattern-amd 模块化设计 http://baike.baidu.com/view/189730.htm模块化 http://baike.baidu.com/view/182267.htm","categories":[{"name":"Font-end","slug":"Font-end","permalink":"https://jiangjingscom.github.io/categories/Font-end/"}],"tags":[{"name":"FontEnd","slug":"FontEnd","permalink":"https://jiangjingscom.github.io/tags/FontEnd/"}]},{"title":"学学python","date":"2021-05-23T14:26:15.000Z","path":"2021/05/23/20210523/","text":"要用 ptyhon 打包一下文件，学了点简单用法。 做个记录～ LEGB 法则：L: local，局部作用域，即函数中定义的变量；E: enclosing，嵌套的父级函数的局部作用域，即包含此函数的上级函数的局部作用域，但不是全局的；G: globa，全局变量，就是模块级别定义的变量；B: built-in，系统固定模块里面的变量，比如 int, bytearray 等;本地作用域（local）&gt; 当前作用域被嵌入的本地作用域（Enclosing locals）&gt; 全局&#x2F;模块作用域（Global） &gt; 内置作用域（Built-in） 作用域的产生在 Python 中，只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域，其它的代码块（如 if、try、for 等）是不会引入新的作用域的。 变量的修改一个不在局部作用域里的变量默认是只读的，如果试图为其绑定一个新的值，python 认为是在当前的局部作用域里创建一个新的变量，也就是说在当前局部作用域中，如果直接使用外部作用域的变量，那么这个变量是只读的，不能修改。 global 关键字当内部作用域想修改外部作用域的变量时，就要用到 global 和 nonlocal 关键字了，当修改的变量是在全局作用域（global 作用域）上的，就要使用 global 先声明一下。 nonlocal 关键字（nonlocal 是 python3 新增的关键字）global 关键字声明的变量必须在全局作用域上，不能嵌套作用域上，当要修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量怎么办呢，这时就需要 nonlocal 关键字了 一个定义于某模块中的函数的全局作用域是该模块的命名空间，而不是该函数的别名被定义或调用的位置","categories":[{"name":"Others","slug":"Others","permalink":"https://jiangjingscom.github.io/categories/Others/"}],"tags":[{"name":"Program","slug":"Program","permalink":"https://jiangjingscom.github.io/tags/Program/"}]},{"title":"关于《30 个提高 Web 程序执行效率的好经验》","date":"2020-12-04T13:16:15.000Z","path":"2020/12/04/20201204/","text":"《30 个提高 Web 程序执行效率的好经验》的理解 尽量避免使用 DOM。当需要反复使用 DOM 时，先把对 DOM 的引用存到 JavaScript 本地变量里再使用。使用设置 innerHTML 的方法来替换 document.createElement&#x2F;appendChild()方 法。测试结果显示使用 innerHTML 对比 document.createElement&#x2F;appendChild()方法，在 IE8 中，效率的提高是非常明显的，但是在 Firefox 和 Chrome 中，差别不大。 eval()有问题，new Fuction()构造函数也是，尽量避免使用它们 eval 方式比直接调用方式多了一步解析的过程，所以尽量避免使用它，如果必须用它，则最好是把调用的代码包装到函数中，然后 eval 这个函数，这样减少了解析的时间。eval 函数的效率，我们可以用如下的代码测试：测试发现，eval 的效率明显慢很多，尤其在 Firefox 和 chrome 中。 new Fuction 的执行原理和 eval 类似，所以效率也是不高。 拒绝使用 with 语句。 它会导致当你引用这个变量时去额外的搜索这样的一个命名空间，with 里的代码在编译时期是完全未知的。原因明确，不过使用 with 语句，代码会非常简洁，我个人还是经常使用这个语句的。 使用 for()循环替代 for…in 循 环。因为 for…in 循环在开始循环之前需要 Script 引擎创建一个含有所有可循环属性的 List，需要多检查一次。原因明确，没有补充。 把 try-catch 语句放在循环外面，不要放在循环里面，因为异常是很少发生的，放在外面避免每次都要执行 它们。原因明确，这是我认为使用任何语言都有必要遵守的准则。 甚至圣经里都提到过这个 – 不要全局的。全局变量的生命周期贯穿整个脚本的生命周期，而本地变量的存在范围随着本地命名空间的销毁而消失。当在函数或其它地方引用一个全局变量时，脚本引擎需要搜索整个全局命名空间。防止内存泄漏和提高查找解析速度，另外，变量定义在最小使用范围内，代码的可读性好。 fullName +&#x3D; ‘John’;fullName+&#x3D;’Holdings’;执行速度快于 fullName+&#x3D;’John’+’Holdings’;测试结果出乎意料，在 IE8 和 chrome 中，两者的效率差不多，但是在 Firefox 中，第一种写法反而比第二种慢很多.IE6 下测试也是如此，看来这条规则还有待进一步研究。 如果你需要把多个字符串连接起来，最好是把他们做成一个数组，然后调用 join()方法实现这个操作。这种方式在生成 HTML 片段时尤其有效。验证还是用测试代码：可以看出，这条规则在主流的浏览器中，效率的差别不大。IE6 下测试，的确第一种比第二种方式效率差很多，所以这条规则已经过时了。 对于简单的任务，最好使用基本操作方式来实现，而不是使用函数调用实现。例如 val1 &lt; val2 ? val1 : val2;执行速度快于 Math.min(val1, val2);，类似的，myArr.push(newEle);慢于 myArr[myArr.length] &#x3D; newEle;这条很好理解，原生态的好。 将函数的引用作为参数传递到 setTimeout()和 setInterval()里优于将函数名作为字符串参数传递（硬编码）。例如，setTimeout(”someFunc()”, 1000)执行效率慢于 setTimeout(someFunc, 1000)道理类似如上的 eval 方式。 当进行遍历操作时避免使用 DOM 操作。通过像 getElementsByTagName()这 种方法得到的 DOM 元素队列都是动态的；有可能在你还没有对它遍历完成时，它已经被改变。这有可能导致死循环。没有补充。 当你对对象的成员（属性或方法）进行反复操作时，先存储对它们的引用。例如 var getTags &#x3D; document.getElementsByTagName; getTags(’div’);这条规则的例子，我认为没有表达规则的意思，所以它举得例子不好。并且我按照它的例子测试，并没有发现两者的差异，所以我重新写测试代码如下：这个结果也很容易理解，毕竟多调用了一次取 DOM 函数! 在任何的代码段里，在局部变量范围外存放一个这个局部变量的引用。例如 1234567function foo(arr) &#123; var a = &quot;something&quot;; //变量 ‘a’ 对于下面的一段就是范围外变量,这个变量的引用在很多情况下会有用处。 for (var i = 0, j = a, loopLen = arr.length; i &lt; loopLen; i++) &#123; //do something &#125;&#125; 没有理解这段的主要意思。 效率。 1for (var i = 0; i &lt; someArray.length; i++) &#123;&#125; 的执行效率慢于 1for (var i = 0, loopLen = someArray.length; i &lt; loopLen; i++) &#123;&#125; 这条也很好理解，第一种方式比第二种方式多了取 Array 长度的步骤。 在 HTTP 头信息里加入缓存控制过期和最大存活时间标记。没有补充 优化 CSS。要使用方式，而不要使用@import 方式。请参考这个优秀的文档http://www.slideshare.net/stubbornella/object-oriented-css没有补充 使用 CSS 技术来优化图片资源.减少图片链接个数，减少网络传输压力。 用 GZip 方式压缩 .js 和 .css 文件。如果你使用的是 Apache，在 .htaccess 里设置压缩方式，你的 HTML, XML 和 JSON 也同时会被压缩。 AddOutputFilterByType DEFLATE text&#x2F;html text&#x2F;css text&#x2F;plain text&#x2F;xml application&#x2F;x-javascript application&#x2F;json 减少传输的压力，增加响应速度。对小型站点，js 和 css 文件不是很大，效果不明显。 使用 JavaScript 压缩工具。除了使用 YUI 和 JSMin 外，你还可以试一试 Google Closure http://closure-compiler.appspot.com/home (感谢: James Westgate, 一位读者)和上面类似，现在有好多 JS 压缩和混淆的工具。 优化每个页面上的各种资源，把它们拆分到各个子域上，这么它们就能够并行下载。请参考http://yuiblog.com/blog/2007/04/11/performance-research-part-4/没有补充。 将 CSS 样式表放在页面的最顶端，这样能方便包括 IE 在内的浏览器进行解析。没有补充。 尽量将 DOM 结构保持的越简单越好。DOM 的体积会影响相关的操作效率，像查找， 遍历，DOM 改动都有影响。document.getElementsByTagName(’*‘).length 这 个值越小越好。没有补充。 注意你使用的选择器。例如，如果你想获取一个 ul 下的直接子元素，使用 jQuery(”ul &gt; li”)而不要使用 jQuery(”ul li”)更快的查找速度，遍历的元素少。 当切换元素的可见性时(display),请记住：element.css({display:none})的 速度快于 element.hide() 和 element.addClass(’myHiddenClass’)。 除非在一个循环里，我选择 element.addClass(’myHiddenClass’)， 这样会使代码更简洁 – 不要使用 inline CSS 和 JavaScript。没有补充。 当你使用完对 DOM 的引用变量后，要把它置为 NULL。资源回收。 使用 AJAX 时，GET 的执行效率高于 POST。所以要尽量使用 GET 方式。只是要注意一点，IE 只允许你用 GET 传送 2K 的数据。同样的信息，GET 方式传输，使用更少的数据量，所以用 GET 方式效率高。但是 GET 方式的安全性不高，传输的数据量受限制。 小心使用脚本动画。没有硬件的支持，动画会执行的很慢。尽量避免使用那些没有实际价值的动画效果。这是每个使用过脚本动画都深有体会的，不过，我认为 HTML5 中 canvas 会广泛地应用，canvas 能做出令人赏心悦目的动画效果，值得大家关注。 如果你的 background-image 对于这个图片的容器太小的话，请避免使 用 background-repeat。如果你的背景图片需要来回填充很多次才能充满背景，那么将 background-repeat 属性设置成 background-image 和 repeat-x 或 repeat-y 来达到填充背景的效果的做法是不明智的，这种填充方式的效率特别的低。你应该尝试使用一个足够大的图片来做 background-image 并且使用 background-repeat:no-repeat。好建议，没有补充 布局时不要使用 table 在浏览器完全把它画出来之前需要反复绘制好几次。因为 DOM 中 table 是很少见的一种之后输出的会影响之前输出的显示效果的元素。对于表格数据来说，你可以使用 table-layout:fixed;这是一种更有效的现实算法，根据 CSS2.1 技术说明，这种写法可以让表格一行一行的输出。除了上面的原因外，table 在样式继承，offset 值计算上，在多浏览器中的表现上，都有不少诡异的差异，例如：如果在 t 中有个元素 div，则取 div 的 offsetParent 返回是 td 元素，并不是我们期望的具有 position 属性的父元素。 尽可能的使用原始 JavaScript。限制 JavaScript 框架的使用。这一条的准则，要看实际的情况，如果项目非常小，则如果使用框架，框架中大部分的 code 是没有用的，这样就额外增加了加载时间。如果是大型项目，则使用成熟框架，如 Jquery 等，不仅能减少开发时间和成本，也减少了后续维护的成本。","categories":[{"name":"Font-end","slug":"Font-end","permalink":"https://jiangjingscom.github.io/categories/Font-end/"}],"tags":[{"name":"FontEnd","slug":"FontEnd","permalink":"https://jiangjingscom.github.io/tags/FontEnd/"}]},{"title":"《node.js 权威指南》笔记","date":"2020-11-24T13:46:15.000Z","path":"2020/11/24/20201124/","text":"《node.js 权威指南》笔记 node.js 存在一个全局作用域 例如 global，代表整个 node.js 中的全局命名空间，任何全局变量、函数和对象都是该对象的一个属性值 全局函数：setTimeout 函数（指定当前时刻过去多少毫秒后执行某个回调函数）和 clearTimeout 函数 setInterval 函数（指定每隔多少毫秒执行某个回调函数）和 clearInterval 函数 使用 require 函数加载模块：require 函数的参数可以为模块名（当使用 node.js 中提供的函数时）或带完整路径的模块名 例如; 定义一个 foo.js 文件，其中代码： 123var testVar = &quot;this is a test&quot;;exports.testVar = testVar; //暴露的对象 在另一个 js 文件中引用模块，代码： 123var foo = require(&quot;./foo.js&quot;);console.log(fo.testVar); node.js 在用于实现各种事件处理的 event 模块中，定义了一个 EventEmitter 类 EventEmitter 类的各种方法有： addListener(event，listener)：对指定事件绑定事件处理函数 on(event,listener)：对指定事件绑定事件处理函数（addlistener 方法的别名） once(event,listener)：对指定事件指定只执行一次的事件处理函数 removeListener(event,listener)：对指定事件移除事件处理函数 removeAllListener([event])：对指定事件解除所有事件处理函数 setmaxListener(n)：指定事件处理函数的最大数量 listeners(event)：获取指定事件的所有事件处理函数 emit(event,[arg1],[arg2],[…])：手工触发指定事件 Buffer 类是一个可以在任何模块中被利用的全局类，不需要为该类的使用而加载任何模块，它拥有三种形式的构造函数 第一种：new Buffer(size) 该对象拥有一个 length 属性，属性值为缓冲区大小 可以使用 fill 方法来初始化缓冲区中的所有内容 第二种：new Buffer(array) 第三种：new Buffer(str,[encoding]) 第一个参数用于初始化缓冲区的字符串，第二个参数用于指定文字编码格式，默认为 utf8 Buffer 类的类方法： isBuffer 方法用于判断是否为 Buffer 对象 byteLength 方法用于计算一个指定字符串的字节数 concat 方法用于将几个 Buffer 对象结合创建为一个新的 Buffer 对象 isEncoding 方法用于检测一个字符串是否为一个有效的编码格式字符串 node.js 操作文件系统 使用 fs 模块来操作有同步和异步两种方法，一般使用异步方法将操作结果作为回调函数的参数进行返回 例如： 12345var fs = require(&quot;fs&quot;);fs.readFile(&quot;./index.html&quot;, &quot;utf8&quot;, function (err, data) &#123; console.log(data);&#125;); 其它方法; fs.writeFile(filename,data,[options],callback) 使用文件流来读取文件： fs.createReadStream(path,[options]) 写文件： fs.createWriteStream(path,[options]) 对路径进行操作： path 模块 path.normalize(p) 将非标准路径字符串转换为标准路径字符串 path.join([path1],[path2],[…]) 将多个参数字符串结合成一个路径字符串 path.resolve(path1,[path2],[…]) path.dirname(p) 获取路径中的目录名 path.basename(p,[ext]) 获取路径中的文件名 http 模块 可以用于创建 HTTP 服务器 例如：在 listen 方法中指定服务器端开始监听时调用的回调函数 123456789var http=require(&#x27;http&#x27;);var server = http.createSever(function(req,res)&#123;&#125;).listen(1337,&quot;127.0.0.1&quot;,function()&#123; console.log(&#x27;服务器开始监听&#x27;)；&#125;)； HTTP 客户端，使用 request 方法向其他网站请求数据 var req&#x3D;http.request(options,callback); 其中 options 参数值为一个对象或字符串，用于指定请求的目标 URL 地址，若为字符串则自动使用 url 模块的 parse 方法转换为一个对象 callback 参数来指定当获取目标网站所返回的相应流是所调用的回调函数 例如：使用 request 方法向其他网站请求数据 123456789101112131415161718var http = request(&#x27;http&#x27;);var options = &#123; hostname:&#x27;www.microsoft.com&#x27;, port:80, path:&#x27;/&#x27;, method:&#x27;GET&#x27;&#125;;var req = http.request(options,function(res)&#123; console.log(&#x27;状态码：&#x27;+res.statusCode); console.log(&#x27;响应头：&#x27;+JSON.stringify(res.hearders)); res.setEncoding(&#x27;utf8&#x27;); res.on(&#x27;data&#x27;,function(chunk)&#123; console.log(&#x27;响应内容：&#x27;+chunk)； &#125;)；&#125;)；req.end(); 可以使用 setTimeout 方法设置端口超时时间 如果使用 GET 方式向其他网站请求数据，也可以使用 http 模块的 get 方法，该方法与 request 方法的区别在于： get 方法只能使用 GET 方式请求数据，使用 get 方法时开发者不需要调用 end 方法，node.js 中将自动调用 end 方法 http.get(options,callback) 使用 node.js 可以轻松实现一个代理服务器 进程与子进程 使用 process 对象代表 node.js 应用程序，该对象是一个全局对象，可以在 REPL 环境中或任何模块中访问该对象。该对象具有一些可被用来获取 node.js 应用程序以及运行该程序的用户、运行环境的各种信息的属性、方法和事件 该对象具有的属性：exexPath、version、platform、argv、env、config、pid、title、arch 进程对象具有的方法： memoryUsage 用于获取 node.js 应用程序的进程的使用量 exit 用于退出运行 node.js 应用程序的进程 node.js 中的进程对象可能触发的事件： exit 事件 例如：exit 事件回调函数的使用实例 12345process.on(&quot;exit&quot;, function () &#123; console.log(&quot;node.js进程被退出。&quot;);&#125;);process.exit(); 各种信号事件 node.js 还提供 child_process 模块开启多个子进程，在多个子进程之间可以共享内存空间，可以通过子进程之间的互相通信来实现信息的交换，多个子进程之间也可以通过共享端口的方式将请求分配给多个子进程来执行 使用 spawn 方法开启一个运行某个命令的子进程： child_process.spawn(command,[args],[options]) command 参数用于指定需要运行的命令 args 参数存放了所有运行该命令时需要使用的参数 options 用于指定开启子进程时使用的选项 使用 fork 方法开启专门运行与 node.js 中的某个模块文件的子进程： child_process.fork(modulePath,[args],[options]) 其中 modulePath 参数值为一字符串，用于指定需要运行该模块文件时需要使用的参数 args 参数值为一个数组，存放运行该模块文件时需要使用的参数 options 为一个对象 用于指定开启子进程时使用的选项，它可指定的属性和属性值有： cwd：指定子进程的当前工作目录 env：为子进程指定环境变量 silent：bool 决定是否与父进程对象共享标准输入&#x2F;输出 encoding：指定标准输出及标准错误输出数据的编码格式 使用 fork 方法时，必须使用呢 process.exit()方法将其显示退出 send 方法： 1234567891011child.send(message,\\[sendHandle\\]) //在父进程中向子进程发送消息process.send(message,\\[sendHandle\\]) //在父进程中向主进程发送消息当子进程接收到消息后，触发process对象的message事件，可以通过该事件进行监听并指定事件回调函数的方法来指定子进程对象接受消息所需要执行的处理：process.on(&#x27;message&#x27;,function(m,setHandle)&#123; //m参数值为子进程中接收到的消息//事件回调函数代码&#125;); 使用 exec 方法开启一个运行于某个命令的子进程，并缓存子进程中的输出结果 child.process.exec(command,[options],[callback]) 使用 execFile 方法开启一个专门运行某个可执行文件的子进程 child.process.execFile(file,[args],[options],[callback]) file 参数值为一个字符串，用于指定需要运行的可执行文件路径及文件名 在 javascript 脚本代码中，虽然可以使用 try…….catch 机制来捕捉同步方法中抛出的错误，但是不能使用 try….catch 机制来捕捉异步方法中抛出的错误 此时可以使用 domain 模块，该模块提供一个 Domain 对象，当应用程序在任何时刻抛出错误时可以通知该对象，然后由该对象来处理这些错误 使用方法： var domain &#x3D; require(‘domain’); var d &#x3D;domain.create(); &#x2F;&#x2F;使用 domain 模块中的 create 方法创建一个 domain 对象 该对象继承了 EventEmitter 实例，因此当它捕捉到错误时，会触发该对象的 error 事件，通过监听该事件并制定回调函数来实现捕捉到错误的处理： domain.on(‘error’,function(err){ &#x2F;&#x2F; 事件回调函数代码 }); 制定该对象的监听代码，使用该对象的 run 方法 domain.run(fn); 当使用 domain 对象的 run 方法指定 domain 对象所要监听的函数时，函数中所有继承了 EventEmitter 类的实例对象都隐式的绑定到了 domain 对象上。 可以使用 domain 对象的 bind 方法，将一个回调函数与该 domain 对象进行绑定： domain.bind(callback); &#x2F;&#x2F;回调函数中必须使用 throw 关键字抛出该错误 可以使用 domain 对象的 intercept 方法拦截一个回调函数中触发的错误 dmain.intercept(callback); &#x2F;&#x2F;错误将直接被 domain 对象拦截 使用 zilb 模块进行压缩与解压缩处理，该模块内部使用 zlib 类库实现 各种用于创建对数据进行压缩及解压缩处理的方法： 1234567zlib.createGzip(\\[options\\]) //使用Gzip算法进行压缩zlib.createDeflate(\\[options\\]) //使用Deflate算法进行压缩处理zlib.createGunzip(\\[options\\]) //对使用Gzip算法进行压缩的数据进行解压缩处理zlib.createInflate(\\[options\\]) //对使用Deflate算法进行压缩的随想进行解压缩处理 使用 express 构建 web 应用程序 var express &#x3D; require(‘express’); var app &#x3D; express(); app 变量值为一个呗创建的 Express 应用程序对象 路由是 express 框架中的重要概念，在 express 框架中使用路由来根据客户端请求所提交的不同 URL 地址返回不同服务器相应结果 在路由中，使用“：”+参数名的方式来指定一个参数","categories":[{"name":"Font-end","slug":"Font-end","permalink":"https://jiangjingscom.github.io/categories/Font-end/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jiangjingscom.github.io/tags/JavaScript/"}]},{"title":"《JavaScript 秘密花园》 笔记","date":"2020-10-23T14:06:01.000Z","path":"2020/10/23/20201023/","text":"《JavaScript 秘密花园》 笔记 对象 1、typeof 一个 JS 变量返回结果：number、boolean、string、function、object（null，数组，对象），undefined。唯一有用的地方即用于检测变量是否被定义（typeof foo !&#x3D;&#x3D; ‘undefined’）。 instanceof 一个 js 对象返回结果：true、false。判断是否是某个对象实例，用于比较不同 JavaScript 上下文的对象时将会出错。 2、js 分为基本类型和对象类型，而普通类型（比如数字 2）被当做构造函数创建的一个对象使用时，JS 会将其转换成一个对象，以其可以使用对象的特性（如方法），而后抛弃对象性质，并将其变回到原始值。 3、除了 null 与 undefined，其他所有数据类型都有 toString 方法 2.toString(); &#x2F;&#x2F;出错，SyntaxError。因为 JavaScript 解析器，会试图将点操作符解析为浮点数字面值的一部分。 (2).toString; &#x2F;&#x2F;‘2’ 通过 Object.prototype.toString.call(obj)可以获取对象 obj 的内部属性[[Class]]的值，用于检测一个对象的类型。 4、删除属性的唯一方法是使用 delete。设置属性为 undefined 或者 null 并不能真正的删除属性，仅移除了属性和值的关联。 5、使用 for in 循环遍历对象时，原型链上的所有属性都将被访问。可以通过 hasOwnProperty 函数来过滤 函数 1、命名函数的赋值表达式 匿名函数的内部可见函数声明，外部不可见。 var foo &#x3D; function bar() { bar(); &#x2F;&#x2F; 正常运行 } bar(); &#x2F;&#x2F;出错 ReferenceError foo(); &#x2F;&#x2F;Uncaught RangeError: Maximum call stack size exceeded 2、变量 arguments 维护所有传递给函数的变量列表，语法上它有数组相关的属性 length，但它实际上是一个对象。 利用 Array.prototype.slice.call(arguments);可以将其转化为数组,slice 去掉了对象.length 属性，并取其他属性组成数组。 3、构造函数。通过 new 关键字方式调用的函数都被认为是构造函数。 数组 1、给数组赋值后，为 length 设置一个更小的值会截断数组，但是增大 length 属性值不会对数组产生影响 2、由于 Array 的构造函数在如何处理参数时模棱两可，因此推荐使用字面语法 []来创建数组。 new Array(3, 4, 5); &#x2F;&#x2F; 结果: [3, 4, 5] new Array(3) &#x2F;&#x2F; 结果: []，此数组长度为 3 new Array(‘3’) &#x2F;&#x2F; 结果: [‘3’] 类型 1、类型转换 隐式转换规则： 1、如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false 转换为 0，而 true 转换为 1; 2、如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值; 字符串转换为数值： （1）数字类型的字符串，会被转成对应十进制的数值； （2）空字符串会转换成 0； （3）其余的全都会转换为 NaN；（NaN 与任何值都不相等，包括自身） 3、如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法，用得到的基本类型值按照前面的规则进行比较; 隐式转换的特殊规则： 1、null 和 undefined 是相等的。 2、要比较相等性之前，不能将 null 和 undefined 转换成其他任何值。 3、如果有一个操作数是 NaN，则相等操作符返回 false，而不相等操作符返回 true。 4、如果两个操作数都是对象，则比较它们是不是同一个对象。（比较引用类型的地址是否相同） 核心 1、不要使用 eval。 eval 只在被调用并且调用函数就是 eval 本身时才在当前作用域中执行。 eval 存在安全问题，它会执行任意传给它的代码，在代码字符串未知或者来自一个不信任的源时，不要用 eval 函数。 2、undefined 是一个值为 undefined 的类型。 会返回 undefined 的情况： 1、访问未修改的全局变量 undefined。 2、由于没有定义 return 表达式的函数隐式返回。 3、return 表达式没有显式的返回任何内容。 4、访问不存在的属性。 5、函数参数没有被显式的传递值。 6、任何被设置为 undefined 值的变量。 3、自动分号插入 其他 1、setTimeout 和 setInterval setTimeout 和 setInterval 也接受第一个参数为字符串的情况，但这个特性绝对不要使用，因为它内部使用了 eval。由于 eval 在这种情况下不是被直接调用的，因此传递到 setTimeout 的字符串会自全局作用中执行。","categories":[{"name":"Font-end","slug":"Font-end","permalink":"https://jiangjingscom.github.io/categories/Font-end/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jiangjingscom.github.io/tags/JavaScript/"}]},{"title":"CDN原理及缓存","date":"2020-09-12T15:16:15.000Z","path":"2020/09/12/20200912/","text":"CDN，即 Content Delivery Network，内容分发网络。 用户在自己的浏览器中输入要访问的网站的域名，浏览器向本地 DNS 请求对改域名的解析，本地的 DNS 将请求发到网站的主 DNS，主 DNS 根据一系列策略确定最适合的 DNS 节点，并将解析的结果发给用户，用户向给定 DNS 节点请求响应网站的内容。 CDN 缓存原理描述 用户输入 URL，浏览器将解析过后的域名发给 DNS 服务器 CDN 返回该域名对应的 CNAME，此时浏览器需要再次对获得的 CNAME 进行解析，才能得到 CDN 缓存服务器的 IP 地址。在此过程中全局负载均衡 DNS 解析服务器会将用户的访问请求定位到离用户最近、负载最轻的 CDN 缓存服务器上。这种技术也被称为“DNS 重定向”，DNS 服务器不是为每个请求返回相同的 IP 地址，比如在悉尼的一个客户请求解析www.cdn.com，DNS服务器根据地理位置，计算出距离这个用户最近的CDN服务器，于是返回一个悉尼CDN节点的IP地址。这种方法也不一定是最优的，因为地理位置上最近的两个点，延迟可能反而很高。还有一种方法是通过估计节点间的样本延迟，具体原理我也不了解。 再次解析后，浏览器得到 CDN 缓存服务器的实际 IP 地址，向缓存服务器发起请求。 缓存服务器根据浏览器提供的域名，通过内部 DNS 解析得到此域名源服务器的真实 IP 地址，再由缓存服务器向该服务器发起访问请求。 缓存服务器拿到数据后，一方面将数据发回浏览器，另一方面进行本地保存，以备后用。之后再次访问，数据将从 CDN 缓存服务器中被返回。CDN 不会永久保存数据，可以设置 CDN 的刷新频率，来达到数据的更新。 浏览器得到由缓存服务器发回的数据，并将其显示出来。至此，完成整个域名访问的过程。 CDN 缓存的缺点 CDN 的分流作用不仅减少了用户的访问延时，也减少的源站的负载。但其缺点也很明显：当网站更新时，如果 CDN 节点上数据没有及时更新，即便用户再浏览器使用 Ctrl +F5 的方式使浏览器端的缓存失效，也会因为 CDN 边缘节点没有同步最新数据而导致用户访问异常。 CDN 缓存策略 CDN 边缘节点缓存策略因服务商不同而不同，但一般都会遵循 http 标准协议，通过 http 响应头中的 Cache-control: max-age 的字段来设置 CDN 边缘节点数据缓存时间。 当客户端向 CDN 节点请求数据时，CDN 节点会判断缓存数据是否过期，若缓存数据并没有过期，则直接将缓存数据返回给客户端；否则，CDN 节点就会向源站发出回源请求，从源站拉取最新数据，更新本地缓存，并将最新数据返回给客户端。 CDN 服务商一般会提供基于文件后缀、目录多个维度来指定 CDN 缓存时间，为用户提供更精细化的缓存管理。 CDN 缓存时间会对“回源率”产生直接的影响。若 CDN 缓存时间较短，CDN 边缘节点上的数据会经常失效，导致频繁回源，增加了源站的负载，同时也增大的访问延时；若 CDN 缓存时间太长，会带来数据更新时间慢的问题。开发者需要增对特定的业务，来做特定的数据缓存时间管理。 CDN 缓存刷新 CDN 边缘节点对开发者是透明的，相比于浏览器 Ctrl+F5 的强制刷新来使浏览器本地缓存失效，开发者可以通过 CDN 服务商提供的“刷新缓存”接口来达到清理 CDN 边缘节点缓存的目的。这样开发者在更新数据后，可以使用“刷新缓存”功能来强制 CDN 节点上的数据缓存过期，保证客户端在访问时，拉取到最新的数据。","categories":[{"name":"Others","slug":"Others","permalink":"https://jiangjingscom.github.io/categories/Others/"}],"tags":[{"name":"FontEnd","slug":"FontEnd","permalink":"https://jiangjingscom.github.io/tags/FontEnd/"}]},{"title":"《改变未来的九大算法》 笔记","date":"2020-08-20T15:36:15.000Z","path":"2020/08/20/20200820/","text":"《改变未来的九大算法》 笔记 伟大算饭筛选条件：计算机用户每天用到、能处理具体现实的问题、算法主要和计算机科学理论相关 搜索引擎： 搜索的两个阶段：匹配和排名 索引、短语查询 词位置把戏 word location trick 元词把戏 metawork trick 谷歌搜索算法：PageRank 算法 技术基础：超链接把戏 –一个网页的链入连接数多则有高排名 权重把戏 the authority trick —与来自低权重的链入链接相比，来自高权重的链入链接更能证明网页排名 权重值和超链接 可能导致循环问题 解决办法：随机访问者把戏 the random surfer trick web spam 网络垃圾 基于链接的排名算法 link-based ranking algorithms 共享密钥 迪菲-赫尔曼密钥交换 diffie-hellman key exchange 颜料混合把戏 paint-mixing trick 需要单向操作 one-way action 混合操作 —&gt;离散指数 discrete exponentiation 分离操作 —&gt;discrete logarithm 钟算 clock arithmetic + 幂指数 power motation 纠错码 计算机三项基本操作：执行计算、存储数据、操作数据 代码字 冗余把戏 –Hamming code 信息理论学 information theory – 香农的《通信的数学理论》The Mathematical Theory of Communication 里德-所罗门代码—基于有限域代数数学分支，结合阶梯校验和二维定点把戏 图形识别 邻分类器 nearest-neighbor classifier 最邻近把戏 决策树 decision tree 人工神经网络 artificial neural network – 每个链接都必须有权重值，每个神经元都必须有个合适的值作为阈值 图灵–1950《计算机器与智能》 数据压缩 无损压缩 —–&gt;更短符号把戏 有损压缩 ——&gt;抛弃把戏 数据库 预写日志记录 write-ahesd logging 两阶段提交 two-phrase commit 关系数据库 relational database 数字签名","categories":[{"name":"Others","slug":"Others","permalink":"https://jiangjingscom.github.io/categories/Others/"}],"tags":[{"name":"Program","slug":"Program","permalink":"https://jiangjingscom.github.io/tags/Program/"}]},{"title":"不同平台差异兼容注意点","date":"2020-07-11T12:16:15.000Z","path":"2020/07/11/20200711/","text":"对于不同平台差异兼容注意点 1、PC 考虑的是浏览器的兼容性，而移动端开发考虑的更多的是手机兼容性，因为目前不管是 android 手机还是 ios 手机，一般浏览器使用的都是 webkit 内核，所以说做移动端开发，更多考虑的应该是手机分辨率的适配，和不同操作系统的略微差异化。 2、在部分事件的处理上，移动端多出来的事件是触屏事件，而缺少的是 hover 事件。 另外包括移动端弹出的手机键盘的处理，这样的问题在 PC 端都是遇不到的。 3、在布局上，移动端开发一般是要做到布局自适应的，使用 rem 布局。 4、在动画处理上，PC 端由于要考虑 IE 的兼容性，所以通常使用 JS 做动画的通用性会更好一些，但是 CSS3 做了很大的牺牲， 而在手机端，如果要做一些动画、特效等，第一选择肯定是 CSS3， 既简单、效率又高。 5、微信的一些接口组好能去实现一遍，熟悉一下肯定是有好处的，比如通过微信分享文章，title、description、icon 等图标的配置，这些还是要会的。百度地图的一些 API 接口，也得去实现一下，这些对于移动端来说，LBS 是一个非常重要的特性，所以地图这块肯定是要了解的，在加上百度地图这块已经是一个比较成熟的平台了，学起来比较容易。","categories":[{"name":"Others","slug":"Others","permalink":"https://jiangjingscom.github.io/categories/Others/"}],"tags":[{"name":"Program","slug":"Program","permalink":"https://jiangjingscom.github.io/tags/Program/"}]},{"title":"《Python 编程：从入门到实践》笔记","date":"2020-05-12T14:36:15.000Z","path":"2020/05/12/20200512/","text":"《Python 编程：从入门到实践》笔记 1、变量和简单基础类型 string &#x3D; ‘lalalla’ 无需声明变量，根据赋值决定类型 1、对字符串进行操作： string.title() 以首字母大写的方式显示 string.upper() 全部以大写的方式显示 string.lower() 全部以小写的方式显示 2、使用制表符或换行符添加空白 \\t \\n 3、删除空白 string.rstrip() 删除字符串末尾多余的空白，删除是暂时的 string.lstrip() 删除字符串开头多余的空白，删除是暂时的 string.strip() 删除字符串两端多余的空白，删除是暂时的 4、数字 两个乘号**表示乘方，使用括号决定运算次序 5、浮点数 python 将带有小数点的数字都成为浮点数，很大程度上使用浮点数无需考虑到它的行为，注意：结果包含的小数位数可能是不确定的 6、使用 str()避免类型错误 str(23) #’23’ 变量的作用域： 几种作用域优先顺序：L&gt; E&gt; G&gt; B Llocal,局部作用域，即函数中定义的变量 Eenclosing，嵌套的父级函数的局部作用域，即包含此函数的上级函数的局部作用域，但并不是全局的 G global，全局变量，就是模块级别定义的变量 B built-in，系统固定模块里面的变量，比如 int byte array 等。 作用域的产生： 会引入新的作用域：模块（module）、类（class）以及函数（def、lambda） 不会引入新的作用域：其他的代码块（如 if、try、for 等），python 没有块级作用域 变量的修改 一个不在局部作用域里的变量默认是只读的，如果试图为其绑定一个新的值，python 认为是在当前的局部作用域里创建一个新的变量。 可以先使用 global（在全局作用域时）或 nonlocal（在副作用域时）声明，再修改 2、列表 –一系列按特定顺序排列的元素组成，有序集合 list &#x3D; [‘lalallala’, ‘hahahhaha’] 1、python 支持 负数索引，即用 list[-1]表示访问作用一个元素，用 list[-2]表示访问倒数第二个元素 2、 添加元素 list.append(‘hello’) 将新元素 hello 添加至末尾 list.insert(0， ‘world’)将新元素 world 插入至索引为 0 处 3、 删除元素 del list[0] 知道元素在列表中的位置，可以使用 del list.pop() 删除列表末尾的元素 list.pop(0) 弹出列表中任何位置处的元素 list.remove(‘lalallalal’) 根据值来删除元素 4、 组织排序 list.sort()对列表进行永久性排序 sorted(list) 对列表进行临时性排序 list.reverse() 反转列表中的值 len(list)确定列表的长度 5、 遍历整个列表 for…in… 6、 创建数值列表 range(1,5) #[1, 2, 3, 4] 计算 min、max、sum 7、使用列表的一部分 - 创建切片 list[1:4] 提取出 list[1]、list[2]、list[3] 8、 复制列表 list[:] 3、元组 –不可变的列表（不可修改元组内的元素，可以修改元组变量），使用方括号标识 1、遍历元组中的值 for….in…. 2、设计代码格式 python 用缩进而不是{}标识代码块 4、if 语句 if message &#x3D;&#x3D; true 1、相等（&#x3D;&#x3D;）和不相等（!&#x3D;） 2、检查 多个条件 使用 and 或 or 3、不同的 if 语句 if、if-else、if- elif-else、if-elif-elif-elif-else、省略 else（python 并不要求 if-elif 后面必须要有 else） 5、字典 – 在 python 中，字典是一系列键-值对（键必须是唯一的），用{}来表示。 1、 访问字典中的值 dic[‘key’] 2、删除键值对 del dic[‘key’] 3、 遍历字典-遍历键值对时，键值对的返回顺序与存储顺序不同，python 不关心键值对的存储顺序，只跟踪键和值之间的关联关系 for key,value in dic.items() 遍历键-值对 for name in dic.keys() 遍历所有键 for name in sorted(dic.keys()) 按顺序遍历字典中的所有键 for language in dic.values() 遍历字典中的所有值 for language in set(dic.values()) 遍历字典中的所有值，使用 set()获取所有唯一值（去掉重复值） 4、嵌套 字典列表 在字典中存储列表 在字典中存储字典 6、用户的输入和 while 循环 1、 input() 让程序暂停运行，等待用户输入一些文本；python 将用户的输入解读为字符串 2、 int() 获取数值输入 3、求模运算符 % 将两个数相除并返回它的余数 4、 while 循环 7、函数 def foo(name) print(name) foo(‘jiangjing’) 1、形参(name) –函数完成工作所需要的一项信息 2、实参(‘jiangjing’) –调用函数时传递给函数的信息 3、关键字实参 传递给函数的名称-值对 4、 形参指定默认值 5、 传递任意数量的实参 def foo(*names) 6、将 函数存储在模块中 比如在 test.py 文件中构建函数： def getColor(colors): for color in colors: print(colors) 在文件中引用它： import test test.getColor([‘green’, ‘’red’]) 7、 导入特定的函数 from module_name inport function_1,function_2 8、用 as 给函数指定别名 from module_name inport function_1 as foo 9、用 as 给模块指定别名 import test as myTest 10、导入模块中的所有函数 from test import * 使用模块中的函数 test() 8、类 1、 创建一个类 class Dog() def _init_(self,name,age): self.name &#x3D; name self.age &#x3D; age def sit(self) print(self.name.title()) 使用： myDog &#x3D; Dog(‘willie’, 6) 2、使用类和 实例 3、 继承 4、 导入类 5、python 标准库 9、文件 1、 从文件中读取数据 with open(‘test.txt’) as file_object: contents &#x3D; file_object.read print(contents) 2、 逐行读取 with open(test.txt) as file_object: for line in file_object: print(line) 3、 写入空文件 with open(test.txt, ‘w’) as file_object: file_object.write(‘I love programming’) 1、打开文件时，可指定读取模式（’r’）、写入模式（’w’）、附加模式（’a’）或者能读取和写入模式（’r+’）,如果你忽略了实参，python 将以默认的只读模式打开文件。 2、如果你要写入的文件不存在，函数 open()将自动创建它。 3、以写入模式（’w’）打开文件时要注意，如果指定的文件已经存在，python 将在返回对象时清空该文件。 4、python 只能将字符串写入文本文件。 4、 附加到文件 如果要给文件添加内容，而不是覆盖原有内容，可以使用附加模式打开文件，这样写入的行都会添加到文件末尾。 如果指定的文件不存在，python 将会为你创建一个空文件。 10、异常 python 使用被称为异常 的对象来管理程序执行期间发生的错误 1、处理 ZeroDivisionError 异常 try-except 代码块 2、处理 FileNotFoundError 异常 try-except 代码块 3、 存储数据和重构 11、测试代码 单元测试用于核实函数的某个方面没有问题， 测试用例是一组单元测试","categories":[{"name":"Others","slug":"Others","permalink":"https://jiangjingscom.github.io/categories/Others/"}],"tags":[{"name":"Program","slug":"Program","permalink":"https://jiangjingscom.github.io/tags/Program/"}]},{"title":"关于浏览器缓存","date":"2020-04-13T14:04:30.000Z","path":"2020/04/13/20200423/","text":"浏览器缓存 浏览器缓存保存着用户通过 HTTP 获取的所有资源，在下一次请求时可以避免向服务器发出多余的请求 浏览器的缓存分为两类：强缓存、协商缓存（对比缓存）。 浏览器在第一次请求发生后，再次请求时：1、浏览器会先获取该资源缓存的 header 信息，根据其中的 expires 和 cahe-control 判断是否命中强缓存，若命中则直接从缓存中获取资源，包括缓存的 header 信息，本次请求不会与服务器进行通信；2、如果没有命中强缓存，浏览器会发送请求到服务器，该请求会携带第一次请求返回的有关缓存的 header 字段信息（Last-Modified&#x2F;IF-Modified-Since、Etag&#x2F;IF-None-Match）,由服务器根据请求中的相关 header 信息来对比结果是否命中协商缓存，若命中，则服务器返回新的响应 header 信息更新缓存中的对应 header 信息，但是并不返回资源内容，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容 强缓存：1、查看该资源缓存的 header 头中的 Expire 和 Cache-control 来判断是否满足规则；Expire：HTTP&#x2F;1.0 规范表示缓存到期时间，值为一个绝对时间的 GMT 格式时间的字符串缺点：是一个绝对时间，修改客户端的本地时间，缓存失效？Cache-control：HTTP&#x2F;1.1 新增字段_ no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在 ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。_ no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。_ public：默认设置。可以被所有的用户缓存，包括终端用户和 CDN 等中间代理服务器。_ private：不能被多用户共享。只能被终端用户的浏览器缓存，不允许 CDN 等中继缓存服务器对其缓存。 * max-age：表示资源缓存的最大有效时间，相对时间。单位为秒Cache-control 优先级高于 Expire2、如果满足规则，就返回缓存的数据3、如果不满足规则，就向服务器发送请求4、服务器返回数据5、将新数据存入缓存 协商缓存：当强缓存没有命中时，浏览器会发送一个请求到服务器，服务器根据请求中的部分信息来判断是否命中缓存。如果命中，则返回 304，告诉浏览器资源未更新，可使用本地缓存。1、把资源标识，比如 If-Modify-Since 或 Etag 发送到服务器，确认资源是否更新Last-Modify&#x2F;If-Modify-Since:浏览器第一次请求一个资源的时候，服务器返回的 header 中会加上 Last-Modify，Last-modify 是一个时间标识该资源的最后修改时间，例如 Last-Modify: Thu,31 Dec 2037 23:59:59 GMT.当浏览器再次请求该资源时，request 的请求头中会包含 If-Modify-Since，该值为缓存之前返回的 Last-Modify。服务器收到 If-Modify-Since 后，根据资源的最后修改时间判断是否命中缓存。如果命中缓存，则返回 304，并且不会返回资源内容，并且不会返回 Last-Modify。ETag&#x2F;If-None-Match：Etag&#x2F;If-None-Match 返回的是一个校验码。ETag 可以保证每一个资源是唯一的，资源变化都会导致 ETag 变化。服务器根据浏览器上送的 If-None-Match 值来判断是否命中缓存。与 Last-Modified 不一样的是，当服务器返回 304 Not Modified 的响应时，由于 ETag 重新生成过，response header 中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化。两者使用原因： 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新 GET； 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说 1s 内修改了 N 次)，If-Modified-Since 能检查到的粒度是 s 级的，这种修改无法判断(或者说 UNIX 记录 MTIME 只能精确到秒) 某些服务器不能精确的得到文件的最后修改时间。Last-Modified 与 ETag 是可以一起使用的，服务器会优先验证 ETag，一致的情况下，才会继续比对 Last-Modified，最后才决定是否返回 304。2、如果资源未更新，请求响应返回的 http 状态为 304 并且显示一个 Not Modified 字符串，告诉浏览器使用本地缓存。3、如果资源已经更新，返回新的数据4、将新的数据存入缓存 另外：请求头里的 Cache-Control 是 no-cache，表示不读取浏览器缓存数据。响应头中的 Cache-Control 是 no-cache 是通知浏览器，不要缓存以上的该资源缓存的 header 信息是指浏览器缓存请求中的响应头中的 Cache-Control","categories":[{"name":"Font-end","slug":"Font-end","permalink":"https://jiangjingscom.github.io/categories/Font-end/"}],"tags":[{"name":"FontEnd","slug":"FontEnd","permalink":"https://jiangjingscom.github.io/tags/FontEnd/"}]},{"title":"不同的HTTP","date":"2019-12-03T13:22:01.000Z","path":"2019/12/03/20191203/","text":"HTTP 是基于 TCP&#x2F;IP 协议的应用层协议。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用 80 端口。 1、HTTP&#x2F;0.9 最早版本是 1991 年发布的 0.9 版。该版本极其简单，只有一个命令 GET。 GET &#x2F;index.html表示，TCP 连接（connection）建立后，客户端向服务器请求（request）网页 index.html。协议规定，服务器只能回应 HTML 格式的字符串，不能回应别的格式。服务器发送完毕，就关闭 TCP 连接。 2、HTTP&#x2F;1.0 1996 年 5 月，HTTP&#x2F;1.0 版本发布，内容大大增加。任何格式的内容都可以发送；引入了 POST 命令和 HEAD 命令；HTTP 请求和回应的格式也变了，除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据；其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。 请求格式：GET &#x2F; HTTP&#x2F;1.0User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10*10_5)Accept: *&#x2F;_第一行是请求命令，必须在尾部添加协议版本（HTTP&#x2F;1.0）。后面就是多行头信息，描述客户端的情况。 回应格式：HTTP&#x2F;1.0 200 OKContent-Type: text&#x2F;plainContent-Length: 137582Expires: Thu, 05 Dec 1997 16:00:00 GMTLast-Modified: Wed, 5 August 1996 15:55:28 GMTServer: Apache 0.84 12345&lt;html&gt; &lt;body&gt; Hello World &lt;/body&gt;&lt;/html&gt; 回应的格式是”头信息 + 一个空行（\\r\\n） + 数据”。其中，第一行是”协议版本 + 状态码（status code） + 状态描述”。 Content-Type：关于字符的编码，1.0 版规定，头信息必须是 ASCII 码，后面的数据可以是任何格式。因此，服务器回应的时候，必须告诉客户端，数据是什么格式，这就是 Content-Type 字段的作用。 text&#x2F;plain text&#x2F;html text&#x2F;css image&#x2F;jpeg image&#x2F;png image&#x2F;svg+xml audio&#x2F;mp4 video&#x2F;mp4 application&#x2F;javascript application&#x2F;pdf application&#x2F;zip application&#x2F;atom+xml这些数据类型总称为 MIME type，每个值包括一级类型和二级类型，之间用斜杠分隔。MIME type 还可以在尾部使用分号，添加参数。Content-Type: text&#x2F;html; charset&#x3D;utf-8 表明，发送的是网页，而且编码是 UTF-8。客户端请求的时候，可以使用 Accept 字段声明自己可以接受哪些数据格式。Accept: &#x2F; 表示，客户端声明自己可以接受任何格式的数据。 Content-Encoding：由于发送的数据可以是任何格式，因此可以把数据压缩后再发送。Content-Encoding 字段说明数据的压缩方法。 Content-Encoding: gzip Content-Encoding: compress Content-Encoding: deflate客户端在请求时，用 Accept-Encoding 字段说明自己可以接受哪些压缩方法。Accept-Encoding: gzip, deflate HTTP&#x2F;1.0 版的主要缺点是，每个 TCP 连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。为了解决这个问题，有些浏览器在请求时，用了一个非标准的 Connection 字段。Connection: keep-alive 表示，要求服务器不要关闭 TCP 连接，以便其他请求复用。服务器同样回应这个字段。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。 3、HTTP&#x2F;1.1 1997 年 1 月，HTTP&#x2F;1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议，一直用到了 20 年后的今天，直到现在还是最流行的版本。 1.1 版的最大变化，就是引入了持久连接（persistent connection），即 TCP 连接默认不关闭，可以被多个请求复用，不用声明 Connection: keep-alive。目前，对于同一个域名，大多数浏览器允许同时建立 6 个持久连接。 1.1 版还引入了管道机制（pipelining），即在同一个 TCP 连接里面，客户端可以同时发送多个请求。这样就进一步改进了 HTTP 协议的效率。举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。管道机制则是允许浏览器同时发出 A 请求和 B 请求，但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求。 Content-length：一个 TCP 连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是 Content-length 字段的作用，声明本次回应的数据长度。Content-Length: 3495 表示，告诉浏览器本次回应的长度是 3495 个字节，后面的字节就属于下一个回应了。在 1.0 版中，Content-Length 字段不是必需的，因为浏览器发现服务器关闭了 TCP 连接，就表明收到的数据包已经全了。 Transfer-Encoding：对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用”流模式”（stream）取代”缓存模式”（buffer）。只要请求或回应的头信息有 Transfer-Encoding 字段，就表明回应将由数量未定的数据块组成。Transfer-Encoding: chunked 1.1 版还新增了许多动词方法：PUT、PATCH、HEAD、 OPTIONS、DELETE。 另外，客户端请求的头信息新增了 Host 字段，用来指定服务器的域名。有了 Host 字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。 虽然 1.1 版允许复用 TCP 连接，但是同一个 TCP 连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为”队头堵塞”（Head-of-line blocking）。 为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入 CSS 代码、域名分片（domain sharding）等等。如果 HTTP 协议设计得更好一些，这些额外的工作是可以避免的。 4、SPDY 协议 2009 年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP&#x2F;1.1 效率不高的问题。这个协议在 Chrome 浏览器上证明可行以后，就被当作 HTTP&#x2F;2 的基础，主要特性都在 HTTP&#x2F;2 之中得到继承。 5、 HTTP&#x2F;2 2015 年，HTTP&#x2F;2 发布。它不叫 HTTP&#x2F;2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP&#x2F;3。 HTTP&#x2F;1.1 版的头信息肯定是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP&#x2F;2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。 多工：HTTP&#x2F;2 复用 TCP 连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。举例来说，在一个 TCP 连接里面，服务器同时收到了 A 请求和 B 请求，于是先回应 A 请求，结果发现处理过程非常耗时，于是就发送 A 请求已经处理好的部分， 接着回应 B 请求，完成后，再发送 A 请求剩下的部分。这样双向的、实时的通信，就叫做多工（Multiplexing）。 数据流：因为 HTTP&#x2F;2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。HTTP&#x2F;2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流 ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID 一律为奇数，服务器发出的，ID 为偶数。数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM 帧），取消这个数据流。1.1 版取消数据流的唯一方法，就是关闭 TCP 连接。这就是说，HTTP&#x2F;2 可以取消某一次请求，同时保证 TCP 连接还打开着，可以被其他请求使用。客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。 头信息压缩：HTTP&#x2F;2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。 HTTP&#x2F;2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送","categories":[{"name":"Font-end","slug":"Font-end","permalink":"https://jiangjingscom.github.io/categories/Font-end/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jiangjingscom.github.io/tags/JavaScript/"}]},{"title":"《两周自制脚本语言 》读书笔记","date":"2019-11-02T13:17:29.000Z","path":"2019/11/02/20191102/","text":"《两周自制脚本语言 》读书笔记 语言处理器大致分为解释器和编译器 解释器：用于执行程序的软件。如果执行的程序由虚拟机器语言或类似的机器语言写成，这种软件也能称为虚拟机。 编译器：能将某种语言写成的程序转换成另一种语言的程序 通常，Java 语言首先会通过编译器将源代码转换为 Java 二进制代码，并将这种虚拟的机器语言保存在文件中，之后，Java 虚拟机的解释器将执行这段代码。 不过，大多数 Java 虚拟机为了提高性能，会在执行过程中通过编译将一部分 Java 二进制代码直接转换成机器语言使用（这个过程称为动态编译或 JIT 编译）。转换后的机器语言将被载入内存，有硬件执行，无需解释器。 现代解释器内部常采用各种类型的编译器。 语言处理器内部的处理流程 源代码 —- 词法分析 -—&gt; 单词排列 —- 语法分析 -— &gt; 抽象语法树 —- 编译器&#x2F;解释器 -— &gt;其他语言程序&#x2F;程序执行结果。 设计 Stone 语言的语法规则 分割单词 语言处理器的第一个组成部分是词法分分析器，将字符串中的字符以单词为单位分组，切割成多个子字符串。 借助 Java 语言来设计 Stone 语言的处理器 1、设计词法分析器。考虑每一种类型的单词的定义，规定怎样的字符串才能构成 一个单词 Stone 语言支持三种类型的单词：标识符、整型字面量、字符串字面量。 借助正则表达式来定义 Stone 语言的单词： 整型字面量：[0-9]+。从 0-9 中取出一个数字 标识符： 至少需要一个字母、数字或下划线，且首字母不能是数字：[A-Z_a-z][A-Z_a-z0-9]* Stone 语言的标识符包括各类符号，所以完整的标识符规则：[A-Z a-[A-Z a–9 *|&#x3D;&#x3D;|&lt;&#x3D;|&gt;&#x3D;|&amp;&amp;|\\|\\||\\p{Punc。其中 \\ p{Punc}表示与任意一个符号字符匹配 字符串字面量：”(\\\\“ |\\\\\\\\|\\\\n|[^” )*“ 。Java 中两个反斜杠代表\\，因此\\\\\\\\表示匹配一个\\。 用于表示程序的对象 1、抽象语法树定义 语言处理器在词法分析阶段将程序分割为单词后，将开始构造抽象语法树。 抽象语法树 (AST，Abstract Syntax Tree)是一种用于表示程序结构的树形结构。构造抽象语法树的过程称为语法分析，依然属于语言处理器的前半阶段。其主要任务是分析单词之间的关系，如判断哪些单词属于同一个表达式或语句，以及处 理左右括号(单词)的配对等问题。 语法分析的结果能够通过抽象语法树来表示。这一阶段还会 检查程序中是否含有语法错误。 本书使用 Java 语言来实现语言处理器，因此选择通过对象与树形结构来表示程序结构。如果用于实现的不是面向对象语言，表示树形结构的方法也会有所不同。如果是 C 语言，则会使 用结构体;如果是 Scheme 语言，则会使用列表。 2、使用 BNF(巴科斯范式 )或铁路图表示语法 语法规定了单词的组合规则，例如，双目运算表达式应该由哪些单词组成，或是 if 语句 应该具有怎样的结构等。而程序设计语言的语法通常会包含诸如 if 语句的执行方式，或通 过 extends 继承类时将执行哪些处理等规则。 BNF 是 JohBackus 为表达 Algol 语言的语法而设计的，不过最后大家发现它能用于表达语 言学领域中的 Noam Chomsky 上下文无关文法。 在 BNF 的表达规则中， : 左侧所写的内容能够用于表示与在 : 右侧所写的模式相匹配的单词序列。 例如上图第 1 行的规则中，factor(因子)意指与右侧模式匹配的单词序 列。: 左侧出现的诸如 factor 这样的符号称为非终结符或元变量。 与非终结符相对的是终结符，它们是一些事先规定好的符号，表示各种单词。 : 右侧的模式中也包含了若干个终结符或非终结符。 例如上图第 1 行的规则中，factor 能表示 NUMBER(1 个整型字面量单词)，或 由左括号、 expression(表达式)及右括号依次排列而成的单词序列。 expression 是一个非终结符，第 3 行对其下了定义。因此，由左括号、与 expression 匹配的单词序列，及右括号这些单词组成的单词序列能与 factor 模式匹配。 也就是说，与该模式匹配的单词序列就是一个 expression。反之，如果单词序列与模式 expression 不匹配，则会发生语法错误(syntax error)。 模式中包含非终结符是 BNF 的特征之一。具有循环结构的递归定义 也是 BNF 的一个特征。 人们有时会用铁路图而不是 BNF 来表示语法规则。图中的圆圈表示终结符，矩形表示非终结符。箭头的分支与 合并表示模式的循环出现或“or ”的含义。 3、语法分析与抽象语法树 语法分析用于查找与模式匹配的单词序列。查找得到的单词序列是一个具有特定含义的单词组。 分组后的单词能继续与其他单词组一起做模式匹配，组成更大的分组。 通常，抽象语法树用于表示语法分析的 结果，因此需要表现出这些分组之间的包含关系。","categories":[{"name":"Others","slug":"Others","permalink":"https://jiangjingscom.github.io/categories/Others/"}],"tags":[{"name":"Program","slug":"Program","permalink":"https://jiangjingscom.github.io/tags/Program/"}]},{"title":"《JavaScript Promise 迷你书》 笔记","date":"2019-10-20T14:16:15.000Z","path":"2019/10/20/20191020/","text":"《JavaScript Promise 迷你书》 笔记 什么是 Promise 1、Promise 最初提出是在 E 语言中，它是基于并列&#x2F;并行处理设计的一种编程语言。 Node.js 等规定 JavaScript 的回调函数的第一个参数为 Error 对象，这是它的一个惯例。 而 Promise 则是把类似的异步处理对象和处理规则进行规范化，并采用统一的接口编写，而采用规定方法之外的写法都会报错。 2、Promise 的三种状态：Pending、Fulfilled、Rejected 实战 Promise 1、Promise.resolve(value)和 promise.reject(error)，new Promise()方法的快捷方式 2、使用 Promise 可以避免同时使用同步、异步调用可能引起的混乱问题 3、Promise chain，关注 Promise 的执行顺序。 Promise#then 不仅注册一个回调函数，它还会将回调函数的返回值进行变换，创建并返回一个 Promise 对象。 4、Promise.all 接收一个 Promise 对象的数组作为参数，当数组里的所有 Promise 对象全部变为 resolve 或 reject 时，才会去调用.then 方法 5、Promise.race 只要有一个 promise 对象进入 resolve 或 reject 状态，就会进行后面的处理。 6、使用.then 还是使用.catch： .then 方法中的 onRejected 参数所指定的回调函数，实际上针对的是其 promise 对象或者之前的 promise 对象，而不是针对.then 方法里面指定的第一个参数，即 onFulfilled 所指向的对象，因此使用.catch 效果更好。 advanced 1、Promise 的实现类库 如果说一个类库兼容 Promises&#x2F;A+ 的话，那么就是说它除了具有标准的 then 方法之外，很多情况下也说明此类库还支持 Promise.all 和 catch 等功能。 如果我们说一个类库具有 then 兼容性的话，实际上指的是 Thenable ，它通过使用 Promise.resolve 基于 ES6 Promise 的规定，进行 promise 对象的变换。 2、Promise.resolve 的最大特征之一就是可以将 thenable 的对象转换为 promise 对象。 Thenable 风格表现为位于回调和 Promise 风格中间的一种状态，作为类库的公开 API 有点不太成熟，所以并不常见。 Thenable 本身并不依赖于 Promise 功能，但是 Promise 之外也没有使用 Thenable 的方式，所以可以认为 Thenable 间接依赖于 Promise。 3、使用 reject 而不是 throw 在 Promise 中使用 throw 语句的话，很难区分 throw 是我们主动抛出来的，还是因为真正的其它 异常 导致的。 在 then 中使用 reject 的方法，返回的是 promise 对象，那么根据这个 promise 对象的状态，在下一个 then 中注册的回调函数中的 onFulfilled 和 onRejected 的哪一个会被调用也是能确定的。 4、使用 Promise.race 和 delay 取消 XHR 请求 经过一定时间后变为解决状态的 delayPromise 基于 delayPromise 和 Promise.race 的超时实现方式 取消 XHR promise 请求（abort） 通过模块化实现 promise 对象和操作的分离 5、什么是 Promise.prototype.done ES6 Promises 和 Promises&#x2F;A+等在设计上并没有对 Promise.prototype.done 做出任何规定，但是很多实现类库都提供了该方法的实现。 done 并不返回 promise 对象，也就是说，在 done 之后不能使用 catch 等方法组成方法链。 done 中发生的异常会被直接抛给外面，也就是说，不会进行 Promise 的错误处理（Error Handling）。 由于 done 不会返回 promise 对象，所以我们不难理解它只能出现在一个方法链的最后。 此外，我们已经介绍过了 Promise 具有强大的错误处理机制，而 done 则会在函数中跳过错误处理，直接抛出异常。 Promises API Reference 1、Promise#then promise 对象会在变为 resolve 或者 reject 的时候分别调用相应注册的回调函数。 当处理 onFulfilled 和 onRejected 的函数（handler）返回一个正常值的时候，这个值会传递给 promise 对象的 onFulfilled 方法。 当处理 onFulfilled 和 onRejected 的函数（handler）中产生异常的时候，这个值则会传递给 promise 对象的 onRejected 方法。 2、Promise#catch 一个等价于 promise.then(undefined, onRejected) 的语法糖。 3、Promise.resolve 根据接收到的参数不同，返回不同的 promise 对象。 虽然每种情况都会返回 promise 对象，但是大体来说主要分为下面 3 类： 接收到 promise 对象参数的时候，返回的还是接收到的 promise 对象 接收到 thenable 类型的对象的时候，返回一个新的 promise 对象，这个对象具有一个 then 方法 接收的参数为其他类型的时候（包括 JavaScript 对或 null 等），返回一个将该对象作为值的新 promise 对象 4、Promise.reject 返回一个使用接收到的值进行了 reject 的新的 promise 对象。 而传给 Promise.reject 的值也应该是一个 Error 类型的对象。 5、Promise.all 生成并返回一个新的 promise 对象。 参数传递 promise 数组中所有的 promise 对象都变为 resolve 的时候，该方法才会返回， 新创建的 promise 则会使用这些 promise 的值。 如果参数中的任何一个 promise 为 reject 的话，则整个 Promise.all 调用会立即终止，并返回一个 reject 的新的 promise 对象。 由于参数数组中的每个元素都是由 Promise.resolve 包装（wrap）的，所以 Paomise.all 可以处理不同类型的 promose 对象。 6、Promise.race 生成并返回一个新的 promise 对象。 参数 promise 数组中的任何一个 promise 对象如果变为 resolve 或者 reject 的话， 该函数就会返回，并使用这个 promise 对象的值进行 resolve 或者 reject。","categories":[{"name":"Font-end","slug":"Font-end","permalink":"https://jiangjingscom.github.io/categories/Font-end/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jiangjingscom.github.io/tags/JavaScript/"}]},{"title":"关于OPTIONS","date":"2019-09-19T15:10:30.000Z","path":"2019/09/19/20190919/","text":"关于 OPTIONS MDN CORS：规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。 当请求满足下述任一条件时，即应首先发送预检请求：1、使用了下面任一 HTTP 方法： PUT DELETE CONNECT OPTIONS TRACE PATCH2、人为设置了对 CORS 安全的首部字段集合之外的其他首部字段。该集合为： Accept Accept-Language Content-Language Content-Type (需要注意额外的限制) DPR Downlink Save-Data Viewport-Width Width3、Content-Type 的值不属于下列之一: application&#x2F;x-www-form-urlencoded multipart&#x2F;form-data text&#x2F;plain4、请求中的 XMLHttpRequestUpload 对象注册了任意多个事件监听器。5、请求中使用了 ReadableStream 对象。 OPTIONS 是 HTTP&#x2F;1.1 协议中定义的方法，用以从服务器获取更多信息。该方法不会对服务器资源产生影响。 预检请求中同时携带了下面两个首部字段：Access-Control-Request-Method: POSTAccess-Control-Request-Headers: X-PINGOTHER, Content-Type首部字段 Access-Control-Request-Method 告知服务器，实际请求将使用 POST 方法。首部字段 Access-Control-Request-Headers 告知服务器，实际请求将携带两个自定义请求首部字段：X-PINGOTHER 与 Content-Type。服务器据此决定，该实际请求是否被允许。 OPTIONS 请求方法的主要用途有两个：1、获取服务器支持的 HTTP 请求方法；2、用来检查服务器的性能。例如：AJAX 进行跨域请求时的预检，需要向另外一个域名的资源发送一个 HTTP OPTIONS 请求头，用以判断实际发送的请求是否安全。","categories":[{"name":"Font-end","slug":"Font-end","permalink":"https://jiangjingscom.github.io/categories/Font-end/"}],"tags":[{"name":"FontEnd","slug":"FontEnd","permalink":"https://jiangjingscom.github.io/tags/FontEnd/"}]},{"title":"《JavaScript语言精粹》笔记","date":"2019-08-15T12:42:43.000Z","path":"2019/08/15/20190815/","text":"《JavaScript 语言精粹》笔记 JavaScript 的简单类型包括数字、字符串、布尔值（true 和 false）、null 值和 undefined 值。数字、字符串和布尔值貌似对象，因为它们拥有方法 其它所有值都是对象，javascript 中的对象是可变的键控集合，数组、函数、正则表达式都是对象 字面量对象中的属性名可以是包括字符串在内的任何字符串 对象通过引用来传递，永远不会被拷贝 每个对象都连接到一个原型对象，并从中继承属性。所有通过字面量创建的对象都连接到 Object.prototype 这个 JavaScript 中的标准对象 在 JavaScript 中有四种调用模式：方法调用模式、函数调用模式、构造器调用模式和 apply 调用模式。当实际参数的个数与形式参数的个数不匹配时不会导致运行错误 方法调用模式：当一个函数保存为对象的一个属性时，我们称之为方法。方法调用时，this 绑定为该对象 回调： 例如： 123request = prepare_the_request();response = send_request_synchronously(request);display(response); 网络上的同步请求会导致客户端进入假死状态。如果网络传输或服务器很慢，响应的降低是不可接受的 利用异步请求，提供一个当服务器的相应响应到达时被调用的回调函数，异步的函数立即返回，这样浏览器不会被阻塞 1234request = prepare_the_request();send_request_asynchronously&#123;request,function(response)&#123; display(reponse);&#125;&#125;;","categories":[{"name":"Font-end","slug":"Font-end","permalink":"https://jiangjingscom.github.io/categories/Font-end/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jiangjingscom.github.io/tags/JavaScript/"}]},{"title":"css重设（解决浏览器兼容问题）","date":"2019-07-02T13:22:10.000Z","path":"2019/07/02/20190702/","text":"一些可以存下来复用的 css 目前比较全的 CSS 重设(reset)方法总结在当今网页设计&#x2F;开发实践中，使用 CSS 来为语义化的(X)HTML 标记添加样式风格是重要的关键。在设计师们的梦想中都存在着这样的一个完美世界:所有的浏览器都能够理解和适用多有 CSS 规则，并且呈现相同的视觉效果(没有兼容性问题)。但是，我们并没有生活在这个完美的世界，现实中发生的失窃却总是恰恰相反，很多 CSS 样式在不同的浏览器中有着不同的解释和呈现。 当今流行的浏览器(如:Firefox、Opera、Internet Explorer、Chrome、Safari 等等)中，有一些都是以自己的方式去理解 CSS 规范，这就会导致有的浏览器对 CSS 的解释与设计师的 CSS 定义初衷相冲突，使得网页的样子在某些浏览器下能正确按照设计师的想法显示，但有些浏览器却并没有按照设计师想要的样子显示出来，这就导致浏览器的兼容性问题。更糟的是，有的浏览器完全无视 CSS 的一些声明和属性。 正因为上述冲突和问题依然存在于这个”不完美的世界”，所以一些设计师想到了一种避免浏览器兼容性问题的方法，那就是 CSS Reset，什么是 CSS Reset？我们可以把它叫做 CSS 重设，也有人叫做 CSS 复位、默认 CSS、CSS 重置等。CSS 重设就是由于各种浏览器解释 CSS 样式的初始值有所不同，导致设计师在没有定义某个 CSS 属性时，不同的浏览器会按照自己的默认值来为没有定义的样式赋值，所以我们要先定义好一些 CSS 样式，来让所有浏览器都按照同样的规则解释 CSS，这样就能避免发生这种问题。 一.最简化的 CSS Reset(重设) : 1234 &#123; padding: 0; margin: 0;&#125; 这是最普遍最简单的 CSS 重设，将所有元素的 padding 和 margin 值都设为 0，可以避免一些浏览器在理解这两个属性默认值上的”分歧”。 12345 &#123; padding: 0; margin: 0; border: 0;&#125; 这是在上一个重设的基础上添加了对 border 属性的重设，初始值为 0 的确能避免一些问题。 123456 &#123; outline: 0; padding: 0; margin: 0; border: 0;&#125; 在前两个的基础上添加了 outline 属性的重设，防止一些冲突。 二.浓缩实用型 CSS Reset(重设): 1234567891011 &#123; vertical-align: baseline; font-weight: inherit; font-family: inherit; font-style: inherit; font-size: 100%; outline: 0; padding: 0; margin: 0; border: 0;&#125; 该 CSS 重设方法出自 Perishable Press，这是他常用的方法。 三.Poor Man 的 CSS Reset: 12345678910111213141516html,body &#123; padding: 0; margin: 0;&#125;html &#123; font-size: 1em;&#125;body &#123; font-size: 100%;&#125;a img,:link img,:visited img &#123; border: 0px;&#125; 这个重设方法将 html 和 body 下元素的 padding 和 margin 都设为 0，并分别为 html 标签和 body 标签下的所有元素设置了初始的字体大小，最重要的是把有链接的图片的默认边框去掉了。 四.Siolon’s Global Reset 123456789101112131415161718192021222324252627282930313233343536 &#123; vertical-align: baseline; font-family: inherit; font-style: inherit; font-size: 100%; border: none; padding: 0; margin: 0;&#125;body &#123; padding: 5px;&#125;h1,h2,h3,h4,h5,h6,p,pre,blockquote,form,ul,ol,dl &#123; margin: 20px 0;&#125;li,dd,blockquote &#123; margin-left: 40px;&#125;table &#123; border-collapse: collapse; border-spacing: 0;&#125; 五.Shaun Inman’s Global Reset 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,form,fieldset,input,p,blockquote,table,th,td,embed,object &#123; padding: 0; margin: 0;&#125;table &#123; border-collapse: collapse; border-spacing: 0;&#125;fieldset,img,abbr &#123; border: 0;&#125;address,caption,cite,code,dfn,em,h1,h2,h3,h4,h5,h6,strong,th,var &#123; font-weight: normal; font-style: normal;&#125;ul &#123; list-style: none;&#125;caption,th &#123; text-align: left;&#125;h1,h2,h3,h4,h5,h6 &#123; font-size: 1em;&#125;q:before,q:after &#123; content: ”;&#125;a,ins &#123; text-decoration: none;&#125; 六.Yahoo(YUI) CSS Reset: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,form,fieldset,input,textarea,p,blockquote,th,td &#123; padding: 0; margin: 0;&#125;table &#123; border-collapse: collapse; border-spacing: 0;&#125;fieldset,img &#123; border: 0;&#125;address,caption,cite,code,dfn,em,strong,th,var &#123; font-weight: normal; font-style: normal;&#125;ol,ul &#123; list-style: none;&#125;caption,th &#123; text-align: left;&#125;h1,h2,h3,h4,h5,h6 &#123; font-weight: normal; font-size: 100%;&#125;q:before,q:after &#123; content: ”;&#125;abbr,acronym &#123; border: 0;&#125; 七.Eric Meyer’s CSS Reset 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100html,body,div,span,applet,object,iframe,table,caption,tbody,tfoot,thead,tr,th,td,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,dl,dt,dd,ol,ul,li,fieldset,form,label,legend &#123; vertical-align: baseline; font-family: inherit; font-weight: inherit; font-style: inherit; font-size: 100%; outline: 0; padding: 0; margin: 0; border: 0;&#125;:focus &#123; outline: 0;&#125;body &#123; background: white; line-height: 1; color: black;&#125;ol,ul &#123; list-style: none;&#125;table &#123; border-collapse: separate; border-spacing: 0;&#125;caption,th,td &#123; font-weight: normal; text-align: left;&#125;blockquote:before,blockquote:after,q:before,q:after &#123; content: “”;&#125;blockquote,q &#123; quotes: “” “”;&#125; 八.condensedmeyerreset: body, div, dl, dt, dd, ul, ol, li, h1, h2, h3, h4,1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859h5,h6,pre,form,fieldset,input,textarea,p,blockquote,th,td &#123; padding: 0; margin: 0;&#125;fieldset,img &#123; border: 0;&#125;table &#123; border-collapse: collapse; border-spacing: 0;&#125;ol,ul &#123; list-style: none;&#125;address,caption,cite,code,dfn,em,strong,th,var &#123; font-weight: normal; font-style: normal;&#125;caption,th &#123; text-align: left;&#125;h1,h2,h3,h4,h5,h6 &#123; font-weight: normal; font-size: 100%;&#125;q:before,q:after &#123; content: ”;&#125;abbr,acronym &#123; border: 0;&#125; 九.Ateneu Popular CSS Reset 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td &#123; margin: 0; padding: 0; border: 0; outline: 0; font-weight: inherit; font-style: inherit; font-size: 100%; font-family: inherit; vertical-align: baseline;&#125;:focus &#123; outline: 0;&#125;a,a:link,a:visited,a:hover,a:active &#123; text-decoration: none;&#125;table &#123; border-collapse: separate; border-spacing: 0;&#125;th,td &#123; text-align: left; font-weight: normal;&#125;img,iframe &#123; border: none; text-decoration: none;&#125;ol,ul &#123; list-style: none;&#125;input,textarea,select,button &#123; font-size: 100%; font-family: inherit;&#125;select &#123; margin: inherit;&#125;hr &#123; margin: 0; padding: 0; border: 0; color: #000; background-color: #000; height: 1px;&#125; 十.Chris Poteet’s Reset CSS 123456789101112131415161718192021222324252627282930313233343536html &#123; vertical-align: baseline; font-family: inherit; font-style: inherit; font-size: 100%; border: none; padding: 0; margin: 0;&#125;body &#123; padding: 5px;&#125;h1,h2,h3,h4,h5,h6,p,pre,blockquote,form,ul,ol,dl &#123; margin: 20px 0;&#125;li,dd,blockquote &#123; margin-left: 40px;&#125;table &#123; border-collapse: collapse; border-spacing: 0;&#125; 十一.Tantek Celik Reset CSS 123456789101112131415161718192021222324252627282930313233343536373839404142434445link:visited &#123; text-decoration: none;&#125;ul,ol &#123; list-style: none;&#125;h1,h2,h3,h4,h5,h6,pre,code &#123; font-size: 1em;&#125;ul,ol,li,h1,h2,h3,h4,h5,h6,pre,form,body,html,p,blockquote,fieldset,input &#123; margin: 0; padding: 0;&#125;a img,:link img,:visited img &#123; border: none;&#125;address &#123; font-style: normal;&#125; 十二.Christian Montoya Reset CSS 1234567891011121314151617181920212223242526272829303132333435363738394041html,body,form,fieldset &#123; margin: 0; padding: 0; font: 100%/120% Verdana, Arial, Helvetica, sans-serif;&#125;h1,h2,h3,h4,h5,h6,p,pre,blockquote,ul,ol,dl,address &#123; margin: 1em 0; padding: 0;&#125;li,dd,blockquote &#123; margin-left: 1em;&#125;form label &#123; cursor: pointer;&#125;fieldset &#123; border: none;&#125;input,select,textarea &#123; font-size: 100%; font-family: inherit;&#125; 十三.Rudeworks Reset CSS 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147html &#123; font: 62.5% “Lucida Grande”, Lucida, Verdana, sans-serif; text-shadow: #000 0px 0px 0px;&#125;ul &#123; list-style: none; list-style-type: none;&#125;h1,h2,h3,h4,h5,h6,p,pre,blockquote,ul,ol,dl,address &#123; font-weight: normal; margin: 0 0 1em 0;&#125;cite,em,dfn &#123; font-style: italic;&#125;sup &#123; position: relative; bottom: 0.3em; vertical-align: baseline;&#125;sub &#123; position: relative; bottom: -0.2em; vertical-align: baseline;&#125;li,dd,blockquote &#123; margin-left: 1em;&#125;code,kbd,samp,pre,tt,var,input[type=&quot;text&quot;],textarea &#123; font-size: 100%; font-family: monaco, “Lucida Console”, courier, mono-space;&#125;del &#123; text-decoration: line-through;&#125;ins,dfn &#123; border-bottom: 1px solid #ccc;&#125;small,sup,sub &#123; font-size: 85%;&#125;abbr,acronym &#123; text-transform: uppercase; font-size: 85%; letter-spacing: 0.1em; border-bottom-style: dotted; border-bottom-width: 1px;&#125;a abbr,a acronym &#123; border: none;&#125;sup &#123; vertical-align: super;&#125;sub &#123; vertical-align: sub;&#125;h1 &#123; font-size: 2em;&#125;h2 &#123; font-size: 1.8em;&#125;h3 &#123; font-size: 1.6em;&#125;h4 &#123; font-size: 1.4em;&#125;h5 &#123; font-size: 1.2em;&#125;h6 &#123; font-size: 1em;&#125;a,a:link,a:visited,a:hover,a:active &#123; outline: 0; text-decoration: none;&#125;a img &#123; border: none; text-decoration: none;&#125;img &#123; border: none; text-decoration: none;&#125;label,button &#123; cursor: pointer;&#125;input:focus,select:focus,textarea:focus &#123; background-color: #fff;&#125;fieldset &#123; border: none;&#125;.clear &#123; clear: both;&#125;.float-left &#123; float: left;&#125;.float-right &#123; float: right;&#125;body &#123; text-align: center;&#125;#wrapper &#123; margin: 0 auto; text-align: left;&#125; 十四. Anieto2K Reset CSS 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,center,u,b,i &#123; margin: 0; padding: 0; border: 0; outline: 0; font-weight: normal; font-style: normal; font-size: 100%; font-family: inherit; vertical-align: baseline;&#125;body &#123; line-height: 1;&#125;:focus &#123; outline: 0;&#125;ol,ul &#123; list-style: none;&#125;table &#123; border-collapse: collapse; border-spacing: 0;&#125;blockquote:before,blockquote:after,q:before,q:after &#123; content: “”;&#125;blockquote,q &#123; quotes: “” “”;&#125;input,textarea &#123; margin: 0; padding: 0;&#125;hr &#123; margin: 0; padding: 0; border: 0; color: #000; background-color: #000; height: 1px;&#125; 十五.CSSLab CSS Reset 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td &#123; margin: 0; padding: 0; border: 0; outline: 0; font-weight: inherit; font-style: inherit; font-size: 100%; font-family: inherit; vertical-align: baseline;&#125;:focus &#123; outline: 0;&#125;table &#123; border-collapse: separate; border-spacing: 0;&#125;caption,th,td &#123; text-align: left; font-weight: normal;&#125;a img,iframe &#123; border: none;&#125;ol,ul &#123; list-style: none;&#125;input,textarea,select,button &#123; font-size: 100%; font-family: inherit;&#125;select &#123; margin: inherit;&#125;/_ Fixes incorrect placement of numbers in ol’s in IE6/7 _/ ol &#123; margin-left: 2em;&#125;/_ == clearfix == _/ .clearfix:after &#123; content: “.”; display: block; height: 0; clear: both; visibility: hidden;&#125;.clearfix &#123; display: inline-block;&#125;- html .clearfix &#123; height: 1%;&#125;.clearfix &#123; display: block;&#125; 好了，CSS 重设目前先总结到这里，这 15 套重设方法其实都是有共同点的，也许有的实现方法不同，但大部分都是同一个目的，就是为了让更多的浏览器能显示同样的效果。有了这些 CSS 重设作为资料和参考，也许会对你的工作有所帮助甚至提高效率，但是，毕竟这些重设都是别人写的，你完全也可以为自己量身定制一套 CSS 重设。","categories":[{"name":"Font-end","slug":"Font-end","permalink":"https://jiangjingscom.github.io/categories/Font-end/"}],"tags":[{"name":"FontEnd","slug":"FontEnd","permalink":"https://jiangjingscom.github.io/tags/FontEnd/"}]},{"title":"gulp记录","date":"2019-06-23T15:01:30.000Z","path":"2019/06/23/20190623/","text":"gulp 记录 本文主要展示的是 gulp 常用插件的使用方法和用途，通过对插件的熟练运用达到精通 gulp。 What is gulp? gulp 是前端开发过程中一种基于流的代码构建工具，是自动化项目的构建利器；她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用她，不仅可以很愉快的编写代码，而且大大提高我们的工作效率。 gulp 是基于 Nodejs 的自动任务运行器， 她能自动化地完成 javascript、coffee、sass、less、html&#x2F;image、css 等文件的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤。在实现上，她借鉴了 Unix 操作系统的管道（pipe）思想，前一级的输出，直接变成后一级的输入，使得在操作上非常简单。 匹配符 *、**、！、{} 12345gulp.src(&quot;./js/*.js&quot;); // * 匹配js文件夹下所有.js格式的文件gulp.src(&quot;./js/**/*.js&quot;); // ** 匹配js文件夹的0个或多个子文件夹gulp.src([&quot;./js/*.js&quot;, &quot;!./js/index.js&quot;]); // ! 匹配除了index.js之外的所有js文件gulp.src(&quot;./js/**/&#123;omui,common&#125;.js&quot;); // &#123;&#125; 匹配&#123;&#125;里的文件名文件操作; del (替代 gulp-clean) 12var del = require(&quot;del&quot;);del(&quot;./dist&quot;); // 删除整个 dist 文件夹 gulp - rename;描述：重命名文件。 12345678910111213141516171819var rename = require(&quot;gulp-rename&quot;);gulp .src(&quot;./hello.txt&quot;) .pipe(rename(&quot;gb/goodbye.md&quot;)) // 直接修改文件名和路径 .pipe(gulp.dest(&quot;./dist&quot;));gulp .src(&quot;./hello.txt&quot;) .pipe( rename(&#123; dirname: &quot;text&quot;, // 路径名 basename: &quot;goodbye&quot;, // 主文件名 prefix: &quot;pre-&quot;, // 前缀 suffix: &quot;-min&quot;, // 后缀 extname: &quot;.html&quot;, // 扩展名 &#125;) ) .pipe(gulp.dest(&quot;./dist&quot;)); gulp - concat;描述：合并文件。 1234567891011var concat = require(&quot;gulp-concat&quot;);gulp .src(&quot;./js/*.js&quot;) .pipe(concat(&quot;all.js&quot;)) // 合并 all.js 文件 .pipe(gulp.dest(&quot;./dist&quot;));gulp .src([&quot;./js/demo1.js&quot;, &quot;./js/demo2.js&quot;, &quot;./js/demo2.js&quot;]) .pipe(concat(&quot;all.js&quot;)) // 按照[]里的顺序合并文件 .pipe(gulp.dest(&quot;./dist&quot;)); gulp - filter;描述：在虚拟文件流中过滤文件。 12345678910111213141516var filter = require(&quot;gulp-filter&quot;);const f = filter([&quot;**&quot;, &quot;!*/index.js&quot;]);gulp .src(&quot;js/*_/_.js&quot;) .pipe(f) // 过滤掉 index.js 这个文件 .pipe(gulp.dest(&quot;dist&quot;));const f1 = filter([&quot;**&quot;, &quot;!*/index.js&quot;], &#123; restore: true &#125;);gulp .src(&quot;js/*_/_.js&quot;) .pipe(f1) // 过滤掉 index.js 这个文件 .pipe(uglify()) // 对其他文件进行压缩 .pipe(f1.restore) // 返回到未过滤执行的所有文件 .pipe(gulp.dest(&quot;dist&quot;)); // 再对所有文件操作，包括 index.js压缩; gulp-uglify 描述：压缩 js 文件大小。 1234567891011121314151617var uglify = require(&quot;gulp-uglify&quot;);gulp .src(&quot;./hello.js&quot;) .pipe(uglify()) // 直接压缩 hello.js .pipe(gulp.dest(&quot;./dist&quot;));gulp .src(&quot;./hello.js&quot;) .pipe( uglify(&#123; mangle: true, // 是否修改变量名，默认为 true compress: true, // 是否完全压缩，默认为 true preserveComments: &quot;all&quot;, // 保留所有注释 &#125;) ) .pipe(gulp.dest(&quot;./dist&quot;)); gulp-csso描述：压缩优化 css。 123var csso = require(&quot;gulp-csso&quot;);gulp.src(&quot;./css/*.css&quot;).pipe(csso()).pipe(gulp.dest(&quot;./dist/css&quot;)); gulp-html-minify描述：压缩 HTML。 123var htmlminify = require(&quot;gulp-html-minify&quot;);gulp.src(&quot;index.html&quot;).pipe(htmlminify()).pipe(gulp.dest(&quot;./dist&quot;)); gulp-imagemin描述：压缩图片。 123456var imagemin = require(&quot;gulp-imagemin&quot;);gulp .src(&quot;./img/*.&#123;jpg,png,gif,ico&#125;&quot;) .pipe(imagemin()) .pipe(gulp.dest(&quot;./dist/img&quot;)); gulp-zip描述：ZIP 压缩文件。 123456var zip = require(&quot;gulp-zip&quot;);gulp .src(&quot;./src/*&quot;) .pipe(zip(&quot;all.zip&quot;)) // 压缩成 all.zip 文件 .pipe(gulp.dest(&quot;./dist&quot;)); JS&#x2F;CSS 自动注入gulp-autoprefixer 描述：自动为 css 添加浏览器前缀。 123456789101112131415var autoprefixer = require(&#x27;gulp-autoprefixer&#x27;);gulp.src(&#x27;./css/\\*.css&#x27;).pipe(autoprefixer()) // 直接添加前缀.pipe(gulp.dest(&#x27;dist&#x27;))gulp.src(&#x27;./css/\\*.css&#x27;).pipe(autoprefixer(&#123;browsers: [&#x27;last 2 versions&#x27;], // 浏览器版本cascade：true // 美化属性，默认 trueadd: true // 是否添加前缀，默认 trueremove: true // 删除过时前缀，默认 trueflexbox: true // 为 flexbox 属性添加前缀，默认 true&#125;)).pipe(gulp.dest(&#x27;./dist&#x27;)) 查看更多配置：options更多浏览器版本：browsersgulp-useref 描述：解析构建块在 HTML 文件来代替引用未经优化的脚本和样式表。 1234567891011// index.html// gulpfile.jsvar useref = require(&#x27;gulp-useref&#x27;);gulp.src(&#x27;index.html&#x27;).pipe(useref()).pipe(gulp.dest(&#x27;./dist&#x27;))替换之后的 index.html 中就会变成：// 之前的两个替换成一个了 gulp-rev 描述：给静态资源文件名添加 hash 值:unicorn.css &#x3D;&gt; unicorn-d41d8cd98f.css 1234var rev = require(&quot;gulp-rev&quot;);gulp.src(&quot;./css/*.css&quot;).pipe(rev()).pipe(gulp.dest(&quot;./dist/css&quot;));gulp - rev - replace; 描述：重写被 gulp-rev 重命名的文件名。 12345678910var rev = require(&quot;gulp-rev&quot;);var revReplace = require(&quot;gulp-rev-replace&quot;);var useref = require(&quot;gulp-useref&quot;);gulp .src(&quot;index.html&quot;) .pipe(useref()) // 替换 HTML 中引用的 css 和 js .pipe(rev()) // 给 css,js,html 加上 hash 版本号 .pipe(revReplace()) // 把引用的 css 和 js 替换成有版本号的名字 .pipe(gulp.dest(&quot;./dist&quot;)); gulp-html-replace 描述：替换 html 中的构建块。描述：重写被 gulp-rev 重命名的文件名。 12345678910111213141516// index.html// css是buildName,可以自己定义// gulpfile.jsvar htmlreplace = require(&quot;gulp-html-replace&quot;);gulp .src(&quot;index.html&quot;) .pipe( htmlreplace(&#123; css: &quot;all.css&quot;, // css 是 index.html 中定义的 buildName &#125;) ) .pipe(gulp.dest(&quot;./dist&quot;));// 替换之后的 index.html 中就会变成：之前的两个替换成一个了流控制 gulp-if 描述：有条件地运行一个任务。 123456789var gulpif = require(&quot;gulp-if&quot;);var uglify = require(&quot;gulp-uglify&quot;);var concat = require(&quot;gulp-concat&quot;);var condition = true;gulp .src(&quot;./js/*.js&quot;) .pipe(gulpif(condition, uglify(), concat(&quot;all.js&quot;))) // condition 为 true 时执行 uglify(), else 执行 concat(&#x27;all.js&#x27;) .pipe(gulp.dest(&quot;./dist/&quot;)); gulp-load-plugins 描述：从包的依赖和附件里加载 gulp 插件到一个对象里给你选择。 12345678910111213141516171819// package.json&quot;devDependencies&quot;: &#123;&quot;gulp&quot;: &quot;^3.9.1&quot;,&quot;gulp-concat&quot;: &quot;^2.6.1&quot;,&quot;gulp-rename&quot;: &quot;^1.2.2&quot;,&quot;gulp-uglify&quot;: &quot;^2.0.1&quot;&#125;// gulpfile.jsvar $ = require(&#x27;gulp-load-plugins&#x27;)(); // $ 是一个对象,加载了依赖里的插件gulp.src(&#x27;./\\*_/_.js&#x27;).pipe($.concat(&#x27;all.js&#x27;)) // 使用插件就可以用$.PluginsName().pipe($.uglify()) .pipe($.rename(&#x27;all.min.js&#x27;)).pipe(gulp.dest(&#x27;./dist&#x27;)) gulp-sass 描述：编译 sass。 123456789101112var sass = require(&quot;gulp-sass&quot;);gulp .src(&quot;./sass/*_/_.scss&quot;) .pipe( sass(&#123; outputStyle: &quot;compressed&quot;, // 配置输出方式,默认为 nested &#125;) ) .pipe(gulp.dest(&quot;./dist/css&quot;));gulp.watch(&quot;./sass/*_/_.scss&quot;, [&quot;sass&quot;]); // 实时监听 sass 文件变动,执行 sass 任务 gulp-babel 描述：将 ES6 代码编译成 ES5。 12345678910111213var babel = require(&#x27;gulp-babel&#x27;);gulp.src(&#x27;./js/index.js&#x27;).pipe(babel(&#123;presets: [&#x27;es2015&#x27;]&#125;)).pipe(gulp.dest(&#x27;./dist&#x27;))gulp.task(name, fn)这个你应经见过了gulp.run(tasks...)尽可能多的并行运行多个 taskgulp.watch(glob, fn)当 glob 内容发生改变时，执行 fngulp.src(glob)返回一个可读的 streamgulp.dest(glob)返回一个可写的 stream","categories":[{"name":"Font-end","slug":"Font-end","permalink":"https://jiangjingscom.github.io/categories/Font-end/"}],"tags":[{"name":"FontEnd","slug":"FontEnd","permalink":"https://jiangjingscom.github.io/tags/FontEnd/"}]},{"title":"NPM记录","date":"2019-05-02T14:10:30.000Z","path":"2019/05/02/20190502/","text":"NPM 依赖包版本号~和^和*的区别： ~ 会匹配最近的小版本依赖包，比如~1.2.3 会匹配所有 1.2.x 版本，但是不包括 1.3.0 ^ 会匹配最新的大版本依赖包，比如^1.2.3 会匹配所有 1.x.x 的包，包括 1.3.0，但是不包括 2.0.0 这意味着安装最新版本的依赖包推荐使用~，只会修复版本的 bug，比较稳定使用^ ，有的小版本更新后会引入新的问题导致项目不稳定比如：之前的 weex 老项目安装依赖后页面无法显示，修改依赖版本后才正常 NPM script 解释：允许在 package.json 文件中使用 script 字段定义脚本命令，使用 npm run 命令可以查看所有 npm 脚本命令 原理：npm run 会新建一个 shell，在里面执行脚本命令。这个 shell 会将当前目录中的 node_modules&#x2F;.bin 子目录加入 PATH 变量，执行结束后 PATH 变量恢复原样。因此当前目录中的 node_modules&#x2F;.bin 子目录里面所有的脚本，都可以直接用脚本名调用，不必加上路径。 通配符：*.js.其中*表示任意文件名 &#x2F;*.js 其中任意一层子目录 传参：使用–标明 执行顺序：并行执行使用&amp;符号，继发执行使用&amp;&amp;符号 钩子：默认提供一些钩子：prepublish&#x2F;postpublish、prebuild&#x2F;postbuild 简写形式：常用有四个，npm start(nom run start)，npm stop(nom run stop)，npm test(nom run test)，npm restart(nom run restart) 变量：通过 npmpackage前缀可以拿到 package.json 里面的字段","categories":[{"name":"Font-end","slug":"Font-end","permalink":"https://jiangjingscom.github.io/categories/Font-end/"}],"tags":[{"name":"FontEnd","slug":"FontEnd","permalink":"https://jiangjingscom.github.io/tags/FontEnd/"}]},{"title":"《MySQL 入门很简单》笔记","date":"2019-04-21T15:12:30.000Z","path":"2019/04/21/20190421/","text":"《MySQL 入门很简单》笔记 1、数据库概述 长期存储于计算机内、有组织的和可共享的数据集合。表是数据库存储数据的基本单位。 1、数据库理论基础 1、数据存储方式：人工管理阶段 --&gt; 文件系统阶段 --&gt; 数据库系统阶段 2、 数据库泛型（数据库理应遵循的规则）： 第一范式（1NF）：表中不能有重复字段，并且每个字段不能再拆分 第二范式（2NF）：在1NF的基础上，消除了非主属性对于码的部分函数依赖（ 表中的字段必须完全依赖于全部主键而非部分主键） 第三范式（3NF）：在2NF的基础上，消除了非主属性对于码的传递函数依赖（ 非主键外的所有字段必须互不依赖） BCN范式（BCNF）：在3NF的基础上，消除了主属性对于码的部分与传递函数依赖（ 消除表中的多值依赖） 2、数据库技术构成 1、数据库系统（DBS） 2、SQL语言（Structured Query language结构化查询语言）： 数据定义语言（DDL）：定义数据库、表、视图、索引和触发器等。其中包括CREATE语句、AFTER语句、DROP语句 数据操作语言（DML）：用于插入数据、查询数据、更新数据和删除数据等。其中包括INSERT语句、SELECT语句、UPDATE语句和DELETE语句。 数据控制语言（DCL）：用于控制用户的访问权限。其中包括GRANT语句和REVOKE语句。GRANT语句用于给用户增加权限，REVOKE语句用于收回用户权限。 3、数据库访问技术：JDBC 用于执行 SQL 语句的 Java API，JDBC 由一组用 Java 语言编写的类和接口组成 3、MySQL 基础 1、常见的数据库系统：甲骨文的Oracle、IBM的DB2、微软的Access和SQL Server、开源的PostgreSQL、开源的MySQL 2、MySQL 数据类型 MySQL 数据库提供多种数据类型：整数类型、浮点数类型、定点数类型、日期和时间类型、字符串类型和二进制类型。 1、整数类型 标准的SQL中支持INTEGER和SMALLINT两类整数类型。MySQL还扩展支持TINYINT、MEDIUMINT和BIGINT ![](%E3%80%8AMySQL%E5%85%A5%E9%97%A8%E5%BE%88%E7%AE%80%E5%8D%95%E3%80%8B%E7%AC%94%E8%AE%B0.resources/D8FA9B1D-DF06-49AB-AECC-7DC18ABF2FA6.png) 2、浮点数类型和定点数类型 MySQL 中使用浮点数和定点数来表示小数。浮点数包括单精度浮点数（FLOAT 型）和双精度浮点数（DOUBLE 型） 3、日期与时间类型 MySQL 有多种数据类型表示时间。YEAR 表示年份；DATE 表示日期；TIME 表示时间；DATETIME 和 TIMESTAMP 表示日期和时间。 4、字符串类型 字符串类型包括 CHAR、VARCHAR、BLOB、TEXT、ENUM 和 SET CHAR 类型的长度是固定的，建表时指定，长度是0~255之间任意值 VARCHAR 类型的长度是可变的，建表时指定最大长度。其最大值可指定0~65535之间的任意值。 TEXT 类型是一种特殊的字符串类型，只能保存字符数据。 ENUM 类型又称为枚举类型。 5、二进制类型 二进制类型包括BINARY、VARBINARY、BIT、TINYBLOB、BLOB、MEDIUMBLOB和 3、操作数据库 1、创建数据库 在数据库系统中划分一块空间，用来存储相应的数据 创建数据库 语法规则：CREATE DATABASE 数据库名 展示数据库 语法规则：SHOW DATABASE 2、删除数据库 在数据库系统中删除已经存在的数据库 语法规则：DROP DATABASE 数据库名 3、数据语法规则：库存储引擎 决定了 MySQL 数据库中表可以用不同的方式存储 SHOW ENGINES 4、创建表 1、创建表 语法规则：CREATE TABLE 表名 （属性名 数据类型 【完整性约束条件】） 例如：CREATE TABLE example （id INT，name VARCHAR（20），sex BOOLEAN） 2、设置表的主键 主键必须是唯一的；主键是非空字段；用来标识每个记录 1、单字段主键 语法规则：属性名 数据类型 PRIMARY KEY 例如：CREATE TABLE example（stu_id INT PRIMARY KEY） 2、多字段主键 语法规则：PRIMARY KEY（属性1，属性2，...，属性n） 例如：CREATE TABLE example2（stu_id INT，course_id INT，grade FLOAT，PAIMARY KEY（stu_id，course_id））； 3、设置表的外键 设置外键的原则就是必须依赖于数据库中已存在的父表的主键；外键可以为空值；外键的作用是建立该表与其父表的关联关系 语法规则：CONSTRAINT 外键别名 FOREIGN KEY（属性1.1，属性1.2，...，属性1.n） REFERENCES 表名（属性2.1，属性2.2，...，属性2.n） 其中，“外键别名”参数是为外键的代号；“属性1”参数列表是子表中设置的外键；“表名”参数是指父表的名称；“属性2”参数列表是父表的主键。 4、设置表的非空约束 非空性是指字段的值不能为空值 语法规则：属性名 数据类型 NOT NULL 5、设置表的唯一性约束 唯一性是指所有记录中该字段的值不能重复出现 语法规则：属性名 数据类型 UNIQUE 6、设置表的属性值自动增加 AUTO_INCREMENT 用于为表中插入的新纪录自动生成唯一的 ID 语法规则：属性名 数据类型 AUTO\\_INCREMENT 7、设置表的属性的默认值 语法规则：属性名 数据类型 DEFAULT 默认值","categories":[{"name":"Font-end","slug":"Font-end","permalink":"https://jiangjingscom.github.io/categories/Font-end/"}],"tags":[{"name":"Program","slug":"Program","permalink":"https://jiangjingscom.github.io/tags/Program/"}]},{"title":"JavaScript高级程序设计》笔记","date":"2018-12-03T13:03:02.000Z","path":"2018/12/03/20181203/","text":"《JavaScript 高级程序设计》笔记 DOM 是针对 XML 但经过扩展用于 HTML 的应用程序编程接口。它把整个页面映射为一个多层点结构 &lt;script&gt;属性： async:可选，表示应立即下载脚本，只对外部脚本有效….（异步脚本，指定属性让不让页面等待脚本的下载和执行，从而异步加载页面其他内容，建议异步脚本不要在加载期间修改 DOM，异步脚本一定会在页面的 load 事件前执行，但可能在 DOMContentLoaded 事件之前或之后执行，支持异步浏览器：Chrome、Safari5、Firefox3.6） charset：可选，表示通过 src 属性指定代码的字符集 defer：可选，表示脚本可以延迟到文档完全解析和显示之后执行，只对外部脚本有效…. （延迟脚本：支持 HTML5 的实现会忽略给嵌入脚本设置的 defer 属性，最好将延迟脚本放在页面底部） src：可选，表示包含要执行代码的外部文件……（指向服务器上的文件，或域上的文件） type：可选，表示编写代码使用的脚本语言的内容类类型（MIME 类型），一般为 text&#x2F;javascript 将&lt;script&gt;放在&lt;head&gt;内部，需等到所有 js 文件下载、解析、执行完毕后，呈现页面内容。（浏览器在遇到&lt;body&gt;后才开始显示页面），因此一般讲&lt;script&gt;放在&lt;body&gt;中。 驼峰大小写格式（第一个字母小写，其它每个有意义的单词首字母大写） 松散类型： “undefined”–值未定义，使用 var 声明变量，未初始化 “boolean”–布尔值….（区分大小写，字面值只能为 true 或 false） “string”–字符串 “number”–数值 “object”–对象或 null “function’–值是函数 typeof()函数取值类型，typeof(null)返回 object，表示空对象指针 区分 undefined 与 null： 1、undefined 值派生自 null 值，因此 alert(null &#x3D;&#x3D; undefined); &#x2F;&#x2F;true 2、没必要将变量显示设置为 null，但保存对象的变量还没真正保存对象时，应明确让该变量保存 null ECMAScript 中,字符串不可变：var lang &#x3D; “java”;lang &#x3D;lang + “Script”; 表示销毁原来的字符串，新建一个字符串，并填充”java”和”Script” 前置递增和递减（++i）：优先级与执行语句优先级相等，先执行 后置递增和递减（–i）：递增与递减操作在包含他们的语句被求值之后执行 创建 object 实例： 1、使用 new 加 object 构造函数 123var person = new object();person.name = &quot;Nicholas&quot;;person.age = 29; 2、字面量表示法： 1234var person = &#123; name: &quot;Nicholas&quot;, age: 29,&#125;; Array 类型：每一项可以保存任何类型的数据，数组大小可以动态调整 检测数组方法 转换方法：toString()、tolocalString()、valueof() 栈方法 LIFO：push()、pop() 队列方法 FIFO：push()、shift() 重排序方法：降序 reverse()、升序 sort()根据测试字符串改变结果，一般还要用到 compare 函数 操作方法：concat()复制一个数组的副本，可带参，参数也加入数组； slice()，基于某数组创建新数组，参数规定起止位置； splice(0 方法可以根据参数来对数组进行删除、插入、替换等操作 位置方法：indexOf()、lastIndexOf() 两函数参数为要查找的项和(可选)表示查找起点位置的索引，返回查找项在数组中的位置 迭代方法：共五个，接受两个参数：要在每一项上运行的函数和（可选）运行该函数的作用域对象 every(): filter(): foreach(): map(): some(): 缩小方法：reduce()、reduceRight() Date 类型 Date.UTC()、Date.parse() 都返回表示日期的毫秒数。 123456789101112131415var someDate = new Date(Date.parse(&quot;May 25, 2004&quot;)); 同 var someDate = new Date(&quot;May 25,2004&quot;);var y2k = new Date(Date.UTC(2000,0)); //GMT时间2000年1月1日午夜零时var allfives = new Date（Date.UTC(2005,4,5,17,55,55)）; //GMT时间2005年5月5日下午5:55:55Date.now()方法，返回调用此函数时的时间var start = Date.now(); 同 var start = +new Date();doSomething();var stop = Date.now();result = stop-start; RegExp 类型 通过它来支持正则表达式 Function 类型 在 ECMAScript 中，函数都是对象，每个函数都是 Function 类型的实例，而且都与其它引用类型一样具有属性和方法。函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。 例如：使用函数声明语法定义 123function sum(num1, num2) &#123; return num1 + num2;&#125; 同：使用函数表达式定义 12345var sum = function(num1,num2)&#123; return num1=num2；&#125;; 同： 123var sum = new Function(&quot;num1&quot;, &quot;num2&quot;, &quot;return num1+num2&quot;); //不推荐使用一个函数可以有多个名; 例如： 12345function sum(num1, num2) &#123; return num1 + num2;&#125;var anotherSum = sum; //anotherSum与sum均指向同一个函数，因此都可以被调用并返回结果 因此，ECMAScript 中没有函数重载，声明两个同名函数，则后面的函数会覆盖前面的函数 函数声明与函数表达式的区别： 解析器会率先读取函数声明，使其在执行任何代码之前可用（可以访问）……通过一个名为 function declaration hoisting 的过程 而函数表达式，则必须等到解析器执行到它所在的代码行，才真正被解释执行 因此函数可以 作为值 来使用，作为参数传递，或作为返回值 例如： 123function callSomeFunction(someFunction, someArgument) &#123; return someFunction(someArgment);&#125; 函数内部的两个特殊对象：arguments 和 this arguments 包含传入函数的所有餐顺，它有一个 callee 属性,该属性是一个指针，指向拥有这个 arguments 对象的函数 this，行为同 Java 和 C#中的 this 相似，引用的是函数据以执行的环境对象 caller 属性，保存调用当前函数的函数引用 ECMAScript 中的函数都是对象，每个对象包括两个属性;length 和 prototype，length 属性表示希望接收的命名参数的个数，prototype 是保存引用类型的实例方法的真正所在，是不可枚举的 每个函数包含两个非继承而来的方法;apply() 、call() 在特定的作用域中调用函数 基本包装类型：对基本包装类型调用 typeof 会返回”object”,不建议显示创建基本包装类型的对象 3 个特殊的引用类型；Boolean（不建议使用,与布尔值对应的引用类型）、Number、String 例如： 123var s1 = &quot;some text&quot;;var s2 = s1.substring(2); 同： 12345var s1 = new String(&quot;some text&quot;); //创建String类型的一个实例var s2 = s1.substring(2); //在实例上调用指定方法s1 = null; //销毁这个实例 区别基本类型的布尔值与 Boolean 对象： 布尔表达式中的所有对象均转换为 true typeof 操作符，对引用类型（var falseObject &#x3D; new Boolean(false);）返回 object，对基本类型（var falseValue &#x3D; false;）返回 boolean String 类型提供多种方法 单体内置对象：Global（全局）对象、Math 对象 Global 对象包括 URI 编码方法、eval()方法 ECMA-262 把对象定义为：无序属性的集合，其属性包含基本值、对象和函数 属性类型：数据属性、访问器属性 继承是 OO 语言最为突出的概念，许多 OO 语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法 ECMAScript 只支持实现继承，利用原型链来实现。基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法 函数：两种声明 经典递归调用： 1234567function factorial(num)&#123; if(num&lt;=1)&#123; return 1; &#125;else&#123; return num\\*factorial(num-1); &#125;&#125; 更好： 1234567function factorial(num)&#123; if(num&lt;=1)&#123; return 1; &#125;else&#123; return num\\*arguments.callee(num-1); &#125;&#125; 闭包：指有权访问另一个函数作用域中的变量的函数。常见创建闭包的方式：在函数内部创建另一个函数 BOM 浏览器对象模型 DOM 文档对象模型 事件类型 UI 事件：用户与页面上的元素交互时触发 load：当页面完全加载后在 window 上触发，当所有框架加载完毕时在框架上面触发….. 例如： 123456789var image = document.get ElementById (&quot;myImage&quot;);EventUtil.addHandler(image,&quot;load&quot;,function(event)&#123;event = eventUtil.getEvent(event);alert(EventUtil.getTarget(event).src);&#125;); unload：当页面完全卸载后在 window 上面触发。。。。。从一个页面切换到另一个页面 abort： error： select： resize： scroll： 焦点事件 blur：在元素失去焦点时触发，这个事件不会冒泡 focus：在元素获得焦点时触发，这个事件不会冒泡 鼠标与滚动事件 click；单击鼠标左键或按回车键 dblclick：双击 mousedown：按下鼠标任意键 mouseenter： mouseleave： mousemove： mouseout： mouseup： mouseover： 键盘与文本; keydown: keypress: keyup: HTML5 事件： contextmenu 事件 beforeunload 事件 表单： acceptCharset:服务器能够处理的字符集 action:接受请求的 URL elements:表单中的所有空间的集合 enctype:请求的编码类型 length:表单中控件的数量 method:要发送的 HTTP 请求类型 name:表单的名称 reset():将所有表单域重置为默认值 submit():提交表单 target: JSON 语法可以表示三种类型的值，不支持变量、函数或对象实例。用于表示结构化数据….（JSON 字符串必须使用双引号，这是与 JavaScript 字符串最大的区别） 简单值： 对象： { “name”:”Nicholas”, “age”:29, “school”:{ “name”:”lalalalala”, “location”:”hahahah” } } 数组： 12345678910111213&#123; &quot;title&quot;:&quot;Professional Ajax&quot;, &quot;authors&quot;: [ &quot;lalalalal&quot;, &quot;hahahaha&quot; ]&#125; 使用 JSON.stringify()把一个 JavaScript 对象序列化一个 JAON 字符串。除 js 对象外还接受另两个参数，第一个参数是过滤器，第二个参数表示是否在 JSON 字符串中保留缩进 var jsonText &#x3D;JSON.stringify(book); &#x2F;&#x2F;book 是一个 js 对象 将 JSON 字符串直接传递给 JSON.parse()就可以得到相应的 JavaScript 值。接受另外一个参数：还原函数 var bookCopy &#x3D; JSON.parse(jsonText); JavaScript 没有块级作用域 例如： 123for (var i = 0; i &lt; 10; i++) &#123;&#125;alert(i); //10 变量 i 在 for 循环后仍能读取到 i 的值 除非将 var 替换成 let Js 中没有用 var 声明的变量都是全局变量，而且是顶层对象的属性。","categories":[{"name":"Font-end","slug":"Font-end","permalink":"https://jiangjingscom.github.io/categories/Font-end/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jiangjingscom.github.io/tags/JavaScript/"}]},{"title":"逻辑像素pt和物理像素px","date":"2018-10-14T13:06:12.000Z","path":"2018/10/14/20181022/","text":"做个记录，逻辑像素 pt 和物理像素 px pt: html css 中的使用的单位像素 px: 实际上指的是逻辑像素 ptpx: photoshop 测量中的但是实际上指的是物理像素, 物理像素即表示的是一个点, 大小固定一个 pt 可以包含多个物理像素 px 在iphone6中一个单位的逻辑像素包含2个物理像素 iphone的分辨率为375*667 实际上指的是逻辑像素为375*667, 所以一般移动端的设计图纸一般是给的是750*1334, 是因为一个逻辑像素pt包含两个物理像素px 不同设备下的分辨率不同, 在 iphone6s 中 一个逻辑像素 pt 包含三个物理像素 px 即 1pt &#x3D; 3px","categories":[{"name":"Font-end","slug":"Font-end","permalink":"https://jiangjingscom.github.io/categories/Font-end/"}],"tags":[{"name":"FontEnd","slug":"FontEnd","permalink":"https://jiangjingscom.github.io/tags/FontEnd/"}]},{"title":"H5常见问题","date":"2018-09-23T14:36:04.000Z","path":"2018/09/23/20180923/","text":"Meta 基础知识： 1、HTML 页面结构 1234&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;/&gt; &#x2F;&#x2F; width 设置 viewport 宽度，为一个正整数，或字符串‘device-width’ &#x2F;&#x2F; height设置 viewport 高度，一般设置了宽度，会自动解析出高度，可以不用设置 &#x2F;&#x2F;initial-scale 默认缩放比例，为一个数字，可以带小数 &#x2F;&#x2F; minimum-scale允许用户最小缩放比例，为一个数字，可以带小数 &#x2F;&#x2F; maximum-scale允许用户最大缩放比例，为一个数字，可以带小数 &#x2F;&#x2F; user-scalable 是否允许手动缩放 2、空白页基本 meta 标签 1234567891011&lt;!-- 设置缩放 --&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable=no, minimal-ui&quot;/&gt;&lt;!-- 可隐藏地址栏，仅针对IOS的Safari（注：IOS7.0版本以后，safari上已看不到效果） --&gt;&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;&lt;!-- 仅针对IOS的Safari顶端状态条的样式（可选default/black/black-translucent ） --&gt;&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot; /&gt;&lt;!-- IOS中禁用将数字识别为电话号码/忽略Android平台中对邮箱地址的识别 --&gt;&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no, email=no&quot; /&gt; 3、其他 meta 标签 12345678910111213141516171819202122&lt;!-- 启用360浏览器的极速模式(webkit) --&gt;&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot; /&gt;&lt;!-- 避免IE使用兼容模式 --&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;&lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;&lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot; /&gt;&lt;!-- 微软的老式浏览器 --&gt;&lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot; /&gt;&lt;!-- uc强制竖屏 --&gt;&lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot; /&gt;&lt;!-- QQ强制竖屏 --&gt;&lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot; /&gt;&lt;!-- UC强制全屏 --&gt;&lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot; /&gt;&lt;!-- QQ强制全屏 --&gt;&lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot; /&gt;&lt;!-- UC应用模式 --&gt;&lt;meta name=&quot;browsermode&quot; content=&quot;application&quot; /&gt;&lt;!-- QQ应用模式 --&gt;&lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot; /&gt;&lt;!-- windows phone 点击无高光 --&gt;&lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot; /&gt; 4、移动端如何定义字体 font-family @ 中文字体的英文名称 @ 宋体 SimSun @ 黑体SimHei @ 微信雅黑 Microsoft Yahei @ 微软正黑体 Microsoft JhengHei @ 新宋体NSimSun @ 新细明体 MingLiU @ 细明体 MingLiU @ 标楷体 DFKai-SB @ 仿宋 FangSong @楷体 KaiTi @ 仿宋_GB2312 FangSong_GB2312 @ 楷体_GB2312 KaiTi_GB2312 @说明：中文字体多数使用宋体、雅黑，英文用 Helvetica body { font-family: MicrosoftYahei,SimSun,Helvetica; } 5、打电话发短信写邮件 打电话： 1&lt;a href=&quot;tel:0755-10086&quot;&gt;打电话给:0755-10086&lt;/a&gt; 发短信：（winphone 系统无效） 1&lt;a href=&quot;sms:10086&quot;&gt;发短信给: 10086&lt;/a&gt; 写邮件：（注：在添加这些功能时，第一个功能以”?”开头，后面的以”&amp;”开头）普通邮件： 1&lt;a href=&quot;mailto:863139978@qq.com&quot;&gt;点击我发邮件&lt;/a&gt; 收件地址后添加?cc&#x3D;开头，可添加抄送地址（Android 存在兼容问题）： 1&lt;a href=&quot;mailto:863139978@qq.com?cc=zhangqian0406@yeah.net&quot;&gt;点击我发邮件&lt;/a&gt; 6、移动端 touch 事件（区分 webkit 和 winphone） 当用户手指放在移动设备在屏幕上滑动会触发的 touch 事件： &#x2F;&#x2F; 以下支持 webkit touchstart——当手指触碰屏幕时候发生。不管当前有多少只手指 touchmove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用 event 的 preventDefault()可以阻止默认情况的发生：阻止页面滚动 touchend——当手指离开屏幕时触发 touchcancel——系统停止跟踪触摸时候会触发。例如在触摸过程中突然页面 alert()一个提示框，此时会触发该事件，这个事件比较少用 &#x2F;&#x2F;TouchEvent 说明： touches：屏幕上所有手指的信息 targetTouches：手指在目标区域的手指信息 changedTouches：最近一次触发该事件的手指信息 touchend 时，touches 与 targetTouches 信息会被删除，changedTouches 保存的最后一次的信息，最好用于计算手指信息 &#x2F;&#x2F;参数信息(changedTouches[0]) clientX、clientY 在显示区的坐标 target：当前元素 &#x2F;&#x2F;事件响应顺序 ontouchstart &gt; ontouchmove &gt; ontouchend &gt; onclick &#x2F;&#x2F; 以下支持 winphone 8 MSPointerDown——当手指触碰屏幕时候发生。不管当前有多少只手指 MSPointerMove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用 css 的 html{-ms-touch-action: none;}可以阻止默认情况的发生：阻止页面滚动 MSPointerUp——当手指离开屏幕时触发 7、美化表单元素 - 使用 appearance 改变 webkit 浏览器的默认外观 input,select { -webkit-appearance:none; appearance: none; } winphone 下，使用伪元素改变表单元素默认外观 - 禁用 select 默认箭头，::-ms-expand 修改表单控件下拉箭头，设置隐藏并使用背景图片来修饰 select::-ms-expand {display:none; } - 禁用 radio 和 checkbox 默认样式，::-ms-check 修改表单复选框或单选框默认图标，设置隐藏并使用背景图片来修饰input[type&#x3D;radio]::-ms-check, input[type&#x3D;checkbox]::-ms-check { display:none; } 禁用 pc 端表单输入框默认清除按钮，::-ms-clear修改清除按钮，设置隐藏并使用背景图片来修饰 input[type&#x3D;text]::-ms-clear,input[type&#x3D;tel]::-ms-clear, input[type&#x3D;number]::-ms-clear { display:none; } 8、实用的 CSS 样式 &#x2F;&#x2F;去掉 webkit 的滚动条——display: none; &#x2F;&#x2F;其他参数 ::-webkit-scrollba &#x2F;&#x2F;滚动条整体部分 ::-webkit-scrollbar-thumb &#x2F;&#x2F;滚动条内的小方块 ::-webkit-scrollbar-track &#x2F;&#x2F;滚动条轨道 ::-webkit-scrollbar-button&#x2F;&#x2F;滚动条轨道两端按钮 ::-webkit-scrollbar-track-piece &#x2F;&#x2F;滚动条中间部分，内置轨道 ::-webkit-scrollbar-corner &#x2F;&#x2F;边角，两个滚动条交汇处 ::-webkit-resizer&#x2F;&#x2F;两个滚动条的交汇处上用于通过拖动调整元素大小的小控件 &#x2F;&#x2F; 禁止长按链接与图片弹出菜单 a,img { -webkit-touch-callout: none } &#x2F;&#x2F; 禁止 ios 和 android 用户选中文字 html,body {-webkit-user-select:none; user-select: none; }&#x2F;&#x2F; 改变输入框 placeholder 的颜色值 ::-webkit-input-placeholder { &#x2F;_ WebKitbrowsers &#x2F; color: #999; } :-moz-placeholder { &#x2F; Mozilla Firefox 4 to 18 &#x2F;color: #999; } ::-moz-placeholder { &#x2F; Mozilla Firefox 19+ _&#x2F; color: #999; } :-ms-input-placeholder { &#x2F;_ Internet Explorer 10+ _&#x2F; color: #999; }input:focus::-webkit-input-placeholder{ color:#999; } &#x2F;&#x2F; android上去掉语音输入按钮 input::-webkit-input-speech-button {display: none} &#x2F;&#x2F; 阻止 windows Phone 的默认触摸事件 &#x2F;_说明：winphone 下默认触摸事件事件使用 e.preventDefault 是无效的，可通过样式来禁用，如：_&#x2F; html {-ms-touch-action:none; } &#x2F;&#x2F;禁止 winphone 默认触摸事件 1","categories":[{"name":"Font-end","slug":"Font-end","permalink":"https://jiangjingscom.github.io/categories/Font-end/"}],"tags":[{"name":"FontEnd","slug":"FontEnd","permalink":"https://jiangjingscom.github.io/tags/FontEnd/"}]},{"title":"css一些小问题","date":"2018-08-22T15:46:24.000Z","path":"2018/08/22/20180822/","text":"1、class 的写法 两个 class 之间没空格是 一个标签上的 class。例如: 1&lt;div class=&quot;btn btn-primary&quot;&gt;&lt;/div&gt; 有空格 的 如 1&lt;div class=&quot;ui-btn&quot;&gt;&lt;a class=&quot;ui-btn-active&quot;&gt;有空格的&lt;/a&gt;&lt;/div&gt; 当然 对于 12345&lt;div class=&quot;ui-btn&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a class=&quot;ui-btn-active&quot;&gt;有空格的&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 这样子 也是有效的 有空格： .ui-btn .ui-btn-active 的意思是 class&#x3D;ui-btn 标签下的 class&#x3D;ui-btn-active 的标签 （不一定是儿子 是孙子 也可以 ，如果一定要儿子 那么 .ui-btn &gt; .ui-btn-active ） 2、两个 class 用+链接例如：.btn + .btn{}表示连续两个过以上元素用 btn，则从第二个元素开始，使用这个类 3、文字溢出处理： 123456789101112131415//单行.single &#123; overflow: hidden; white-space: nowrap; text-overflow: ellipsis;&#125;//多行.more &#123; display: -webkit-box !important; overflow: hidden; text-overflow: ellipsis; work-break: break-all; -webkit-box-orient: vertical; -webkit-line-clamp: 2; //指定行数&#125; 4、z-indexz-index 属性设置元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。注释：元素可拥有负的 z-index 属性值。注释：Z-index 仅能在定位元素上奏效（例如 position:absolute;）！","categories":[{"name":"Font-end","slug":"Font-end","permalink":"https://jiangjingscom.github.io/categories/Font-end/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jiangjingscom.github.io/tags/JavaScript/"}]},{"title":"《学习JavaScript数据结构与算法》笔记","date":"2018-07-29T14:46:24.000Z","path":"2018/07/29/20180729/","text":"《学习 JavaScript 数据结构与算法》笔记 数组 存储一系列同一种数据类型的值。数组是最简单的内存数据结构 push、pop、unshift、shift、splice、concat、every、some、forEach、map、filter、reduce、reverse、sort、indexOf、lastIndexOf、toString、join 栈 遵循后进先出原则的有序集合。 push、pop、peek、isEmpty、clear、size 十进制转化二进制，任意进制转化二进制 队列 遵循先进先出原则的一组有序的项 enqueue、dequeue、front、isEmpty、size 优先队列、击鼓传花 链表 存储有序的元素集合。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用组成 append、insert、remove、indexOf、removeAt、isEmpty、size、toString 双向链表 链表中，链接是双向的，一个链向下一个元素，另一个链向前一个元素。 循环链表 可以像链表一样只有单向引用，也可以向双向链表一样有双向引用。 集合 由一组无序且唯一（即不能重复）的项组成 add、remove、has、clear、 size、values 集合操作：并集 unionSet、交集 intersectionSet、差集 differenceSet、子集 字典 存储的是【键, 值】，字典也称作映射 set、remove、has、get、clear、size、keys、values 散列表 散列算法的作用是尽可能快地在数据结构中找到一个值。HashTable 类，也叫 HashMap 类，是 Dictionary 类的一种散列表实现方式。散列方法的主要思想是根据结点的关键码值来确定其存储地址：以关键码值 K 为自变量，通过一定的函数关系 h(K)(称为散列函数)，计算出对应的函数值来，把这个值解释为结点的存储地址，将结点存入到此存储单元中。检索时，用同样的方法计算地址，然后到相应的单元里去取要找的结点。 put、remove、get 处理散列表中的冲突。有时候，一些键会有相同的散列值。不同的值在散列表中对应相同位置的时候，我们称其为冲突。 处理冲突有几种方法: 分离链接：为散列表的每一个位置创建一个链表并将元素存储在里面。它是解决冲突的最简单的方法，但是它在 HashTable 实例之外还需要额外的存储空间。 线性探查：当想向表中某个位置加入一个新元素的时候，如果索引 为 index 的位置已经被占据了，就尝试 index+1 的位置。如果 index+1 的位置也被占据了，就尝试 index+2 的位置，以此类推。 树 树是一种分层数据的抽象模型。树是图的一种，无环无向图 节点、根节点、父节点、子节点、内部节点、外部节点、子树、深度、度 二叉树中的节点最多只能有两个子节点:一个是左侧子节点，另一个是右侧子节点。这些定 义有助于我们写出更高效的向&#x2F;从树中插入、查找和删除节点的算法。 二叉搜索树(BST)是二叉树的一种，但是它只允许你在左侧节点存储(比父节点)小的值， 在右侧节点存储(比父节点)大(或者等于)的值。 insert(key)：向树中插入一个新的键值 search(key)：在树中查找一个键，如果节点存在，则返回 true；如果不存在，则返回 false inOrderTraverse：通过中序遍历方式遍历所有节点 preOrderTraverse：通过先序遍历方式遍历所有节点 posetOrderTraverse：通过后序遍历遍历所有节点 min：返回树中最小的值&#x2F;键 max：返回树中最大的值&#x2F;键 remove(key)：从树中移除某个键 树的遍历 树是指访问树的每个节点并对它们进行某种操作的过程。 中序遍历：中序遍历是一种以上行顺序访问 BST 所有节点的遍历方式，也就是以从最小到最大的顺序访问所有节点。 先序遍历：先序遍历是以优先于后代节点的顺序访问每个节点的。先序遍历的一种应用是打印一个结构化的文档。 后序遍历：后序遍历则是先访问节点的后代节点，再访问节点本身。 搜索最大值和最小值 搜索特定的值 移除一个节点 图 网络结构的抽象模型。图是一组由边连接的节点(或顶点)。学习图是重要的，因为任何二元关系都可以用图来表示。 相邻顶点、顶点的度（其相邻顶点的数量）、路径、简单路径（不包含重复的顶点）、环 如果图中不存在环，则称该图是无环的。如果图中每两个顶点间都存在路径，则该图是连通的。 图可以是无向的(边没有方向)或是有向的(有向图)。 如果图中每两个顶点间在双向上都存在路径，则该图是强连通的。 图还可以是未加权的(目前为止我们看到的图都是未加权的)或是加权的。 图的表示 邻接矩阵：图最常见的实现是邻接矩阵。每个节点都和一个整数相关联，该整数将作为数组的索引。 邻接表：邻接表由图中每个顶点的相邻顶 点列表所组成。 关联矩阵：在关联矩阵中，矩阵的行表示顶点，列表示边。关联矩阵通常用于边的数量比顶点多的情况下，以节省空间和内存。 创建图类 图的骨架：使用一个数组（vertices 数组）来存储图中所有顶点的名字以及一个字典（adjList 字典）来存储邻接表。字典将会使用顶点的名字作为键，邻接顶点列表作为值。 图的遍历 和树数据结构类似，我们可以访问图的所有节点。 有两种算法可以对图进行遍历:广度优先搜索(Breadth-First Search，BFS)和深度优先搜索(Depth-First Search，DFS)。 深度优先搜索：会从第一个指定的顶点开始遍历图，沿着路径直到这条路径最后一个顶 点被访问了，接着原路回退并探索下一条路径。换句话说，它是先深度后广度地访问顶点。 排序和搜索算法 冒泡排序：比较任何两个相邻的项，如果第一个比第二个大，则交换它们。复杂度是 O(n2) 选择排序：找到数据结构中的最小值并 2 将其放置在第一位，接着找到第二小的值并将其放在第二位。复杂度为 O(n2) 插入排序：每次排一个数组项，以此方式构建最后的排序数组。 归并排序：一种分治算法。其思想是将原始数组切分成较小的数组，直到每个小数组只有一 个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。复杂度为 O(nlogn)。 快速排序：先从数列中取出一个数作为基准数，分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边，再对左右区间重复第二步，直到各区间只有一个数。 顺序或线性搜索：最基本的搜索算法。它的机制是，将每一个数据结构中的元素和我们要找的元素做比较。 二分搜索：这个算法要求被搜索的数据结构已排序。选择数组的中间值，如果选中值是待搜索值，那么算法执行完毕；如果待搜索值比选中值要小，则在选中值左边的子数组中寻找；如果待搜索值比选中值要大，则在选种值右边的子数组中寻找。 递归 递归并不会无限地执行下去;浏览器会抛出错误，也就是所谓的栈溢出错误(stack overflow error)。根据操作系统和浏览器的不同，具体数值会所有不同，但区别不大。 ECMAScript 6 有尾调用优化(tail call optimization)。如果函数内最后一个操作是调用函数，会通过“跳转指令”(jump) 而不是“子程序调用”(subroutine call)来 控制。也就是说，在 ECMAScript 6 中，没有边界的递归代码可以一直执行下去。 动态规划(Dynamic Programming，DP) 一种将复杂问题分解成更小的子问题来解决的优化技术。 注意：动态规划和分而治之(归并排序和快速排序算法中用到的那种)是不 同的方法。分而治之方法是把问题分解成相互独立的子问题，然后组合它们的答 案，而动态规划则是将问题分解成相互依赖的子问题。 背包问题、最长公共子序列、矩阵链相乘、硬币找零、图的全源最短路径 硬币找零，分解递归得出所有的找零方案，并在程序中通过比较记录下最优解。 贪心算法 遵循一种近似解决问题的技术，期盼通过每个阶段的局部最优选择(当前最好的解)，从而达到全局的最优(全局最优解)。 大 O 表示法 描述算法的性能和复杂程度。 如何衡量算法的效率?通常是用资源，例如 CPU(时间)占用、内存占用、硬盘占用和网络占用。当讨论大 O 表示法时，一般考虑的是 CPU(时间)占用。","categories":[{"name":"Font-end","slug":"Font-end","permalink":"https://jiangjingscom.github.io/categories/Font-end/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jiangjingscom.github.io/tags/JavaScript/"}]},{"title":"浏览器跨域","date":"2018-06-23T15:36:04.000Z","path":"2018/06/23/20180623/","text":"浏览器跨域 浏览器同源策略（协议，端口，主机）不满足同源策略的请求即跨域(一个域名下的 js 脚本未经允许拿不到另一域名下的内容) 跨域的处理方式：1、JSONP由于 script 标签是可以跨域的，因此可以在 html 中增加 script 标签其 src 是跨域链接的请求（后面带上请求 callback 方法），服务端会返回此种请求的结果为 此 callback 并携带数据传参，客户端执行此方法从而实现跨域拿到数据。由于 script 的请求是 GET 的，所以一般来说 JSONP 跨域的请求是 get 请求。这也是一般人们说 AJAX 跨域的实现原理，ajax 里面的 dataType 有个选项是 jsonp。 2、form表单提交可以跨域，但 form post 请求是给另一个域名发送内容。表单提交页面会自动刷新，可以利用隐藏 iframe 创建表单提交。（创建一个隐藏的 form、一个隐藏的 iframe,把表单的 target 指向 iframe 的 name 即可） 3、CORSCORS 是一个 W3C 标准，全称是”跨域资源共享”（Cross-origin resource sharing）CORS 请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）同时满足以下条件，就属于简单请求：（1）使用下列方法之一： GET HEAD POST（2）Fetch 规范定义了对 CORS 安全的首部字段集合，不得人为设置该集合之外的其他首部字段。该集合为： Accept Accept-Language Content-Language Content-Type （需要注意额外的限制） DPR Downlink Save-Data Viewport-Width Width（3）Content-Type 的值仅限于下列三者之一： text&#x2F;plain multipart&#x2F;form-data application&#x2F;x-www-form-urlencoded（4）请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器；（5）请求中没有使用 ReadableStream 对象。 简单请求。浏览器发现这次跨源 AJAX 请求是简单请求，就自动在头信息之中，添加一个 Origin 字段。如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含 Access-Control-Allow-Origin 字段（详见下文），就知道出错了；如果 Origin 指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBar 非简单请求。非简单请求是那种对服务器有特殊要求的请求，比如请求方法是 PUT 或 DELETE，或者 Content-Type 字段的类型是 application&#x2F;json，会在正式通信之前，增加一次 HTTP 查询请求，称为”预检”请求（preflight）。”预检”请求用的请求方法是 OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是 Origin，表示请求来自哪个源。除了 Origin 字段，”预检”请求的头信息包括两个特殊字段 Access-Control-Request-Method、Access-Control-Request-Headers服务器收到”预检”请求以后，检查了 Origin、Access-Control-Request-Method 和 Access-Control-Request-Headers 字段以后，确认允许跨源请求，就可以做出回应。一旦服务器通过了”预检”请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个 Origin 头信息字段。服务器的回应，也都会有一个 Access-Control-Allow-Origin 头信息字段。 4、代理服务端可以随便请求，拿到数据后通过同源接口给客户端或者通过 Nginx 转发等 5、html5 的 postmessage指定请求的域名，向跨域的另一客户端发送信息 6、document.domain适合主域名相同，但子域名不同的 iframe 跨域，端口也需要一致。符合这种情况下的两个页面设置为同一个 domain，就可以互相操作了 7、图片跨域图片引入的 src 可以跨域但是 img 标签不能访问服务器返回的响应内容，也就是说只能单向的发送 get 请求","categories":[{"name":"Font-end","slug":"Font-end","permalink":"https://jiangjingscom.github.io/categories/Font-end/"}],"tags":[{"name":"FontEnd","slug":"FontEnd","permalink":"https://jiangjingscom.github.io/tags/FontEnd/"}]},{"title":"主流浏览器及内核","date":"2018-05-20T14:36:04.000Z","path":"2018/05/20/20180520/","text":"“浏览器内核”无非指的是一个浏览器最核心的部分——“Rendering Engine”，直译这个词汇叫做“渲染引擎”，不过我们也常称其为“排版引擎”、“解释引擎”。这个引擎的作用是帮助浏览器来渲染网页的内容，将页面内容和排版代码转换为用户所见的视图。一个渲染引擎主要包括 HTML 解释器、CSS 解释器、布局和 JavaScript 引擎、绘图等。 HTML 解释器：解释 HTML 文本的解释器，主要作用是将 HTML 文本解释成 DOM(文档对象模型)树，DOM 是一种文档的表示方法. CSS 解释器：级联样式表的解释器，主要作用是为 DOM 中各个元素对象计算出样式信息，从而为计算最后网页的布局提供基础设施。 布局：在 DOM 创建之后，WebKit 需要将其中的元素对象同样式信息结合起来，计算他们的大小位置等布局信息，形成一个能够表示这所有信息的内部表示模型。 JavaScript 引擎：使用 JavaScript 代码可以修改网页的内容，也能修改 CSS 的信息，JS 引擎能够解释 JS 代码并通过 DOM 接口和 CSSOM 接口来修改网页内容和样式信息，从而改变渲染的结果。 绘图：使用图形库将布局计算后的各个网页的节点绘制成图形结果。WebKit 架构 WebCore 部分：包含了目前被各个浏览器所使用的 WebKit 共享部分，是加载和渲染网页的基础部分，具体包括 HTML 解释器、CSS 解释器等。 JavaScriptCore 引擎：是 WebKit 中的默认 JavaScript 引擎。在 Google 的 Chromium 项目中，它被替换为 V8 引擎。 WebKit Ports 部分：是 WebKit 红的非共享部分，属于 WebKit 被移植的模块。由于不同浏览器使得平台差异、依赖的第三方库和需求不同，从而导致多种 WebKit 版本。 WebKit 嵌入式接口：指在 WebCore 和 JavaScript 引擎之上的一层绑定和嵌入式编程接口，可以被各种浏览器调用。 总结一下各常用浏览器所使用的内核。 IE 浏览器内核：Trident 内核，也是俗称的 IE 内核； Chrome 浏览器内核：统称为 Chromium 内核或 Chrome 内核，以前是 Webkit 内核，现在是 Blink 内核； Firefox 浏览器内核：Gecko 内核，俗称 Firefox 内核； Safari 浏览器内核：Webkit 内核； Opera 浏览器内核：最初是自己的 Presto 内核，后来是 Webkit，现在是 Blink 内核； 360 浏览器、猎豹浏览器内核：IE+Chrome 双内核； 搜狗、遨游、QQ 浏览器内核：Trident（兼容模式）+Webkit（高速模式）； 百度浏览器、世界之窗内核：IE 内核； 2345 浏览器内核：以前是 IE 内核，现在也是 IE+Chrome 双内核；手机浏览器种类：UC 浏览器，QQ 浏览器，欧朋浏览器，百度手机浏览器，360 安全浏览器，谷歌浏览器，搜狗手机浏览器，猎豹浏览器，其他杂牌浏览器移动设备浏览器上常用的内核有 Webkit，Blink，Trident，Gecko 等: iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit Android 4.4 之前的 Android 系统浏览器内核是 WebKit Android4.4 系统浏览器切换到了 Chromium(内核是 Webkit 的分支 Blink) Windows Phone 8 系统浏览器内核是 Trident。","categories":[{"name":"Font-end","slug":"Font-end","permalink":"https://jiangjingscom.github.io/categories/Font-end/"}],"tags":[{"name":"FontEnd","slug":"FontEnd","permalink":"https://jiangjingscom.github.io/tags/FontEnd/"}]},{"title":"《图解 HTTP》笔记","date":"2018-04-20T13:36:04.000Z","path":"2018/04/20/20180420/","text":"《图解 HTTP》笔记 1、了解 web 和网络基础 1、TCP&#x2F;IP 协议-是互联网相关各类协议族的总称 [应用层] ：决定向用户提供应用服务时通信的活动 FTP（文件传输协议）、DNS（域名系统）、HTTP 协议 [传输层] ：提供网络连接中两台计算机之间的数据传输 TCP（传输控制协议）、UDP（用户数据协议） [网络层] ：处理在网络上流动的数据包，规定了通过怎样的传输路线到达对方计算机并把数据包传送给对方 IP（网际协议） [数据链路层] ：用来处理连接网络的硬件部分，包括控制操作系统、硬件的设备驱动、网卡及光纤等 a、IP 协议 --把各种数据包传送给对方，ip----&gt;使用 ARP 协议反查 MAC 地址-----&gt;经过多次路由中转-----&gt;目标（该 ip）接收端 b、TCP 协议 --提供可靠的字节流服务，三次握手策略 发送端 ------ 带 SYN 标志的数据包 ------&gt; 对方 发送端 &lt;------ 带 SYN&#x2F;ACK 标志的数据，传达确认信 ------ 对方 发送端 ------ 带 ACK 标志的数据包，握手结束 ------&gt; 对方 c、DNS 服务 提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务 2、URI（统一资源标识符）和 URL（统一资源定位符） 2、简单的 HTTP 协议 1、HTTP 是不保存状态的协议 2、HTTP 方法 GET、POST、HEAD、DELETE、OPTIONS、TRACE、CONNECT 3、持久连接 4、 Cookie 技术保存状态（响应报文中的 Set-Cookie 首字段信息） 3、HTTP 报文内的 HTTP 信息 1、报文结构。报文首部（服务端或客户端须处理的请求或响应的内容及属性） + 空行（CR + LF） + 报文主体（应被发送的数据） 请求报文的结构：请求行+请求首部字段+通用首部字段+实体首部字段+其他 响应报文的结构：状态行+响应首部字段+通用首部字段+实体首部字段+其他 2、内容编码 。gzip（gunzip）、compress（unix 系统的标准压缩）、deflate（zlib）、identity 报文与实体的差异： 报文：是 HTTP 通信中的基本单位，由 8 位组字节流组成,，通过 HTTP 通信传输。 实体：作为请求或响应的有效载荷数据被传输，其内容由实体首部和实体主体组成。 3、状态码 4、与 HTTP 协作的 web 服务器 1、用 单台虚拟主机实现多个域名 两个域名不同的网站同时部署在同一个服务器（相同的 ip 地址）上，使用 DNS 解析域名后，两者访问的 ip[地址会相同]{style&#x3D;”line-height: 1.45;”} 2、通信数据转发程序：代理、网关、隧道 代理是一种有转发功能的应用程序 基本行为：接收客户端发送的请求后转发给其他服务器； 两种基准分类：a、是否使用缓存；b、是否会修改报文 网关 是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。可能客户端都不会察觉，它的通信目标是一个网关 利用网关可以由 HTTP 请求转化为其他协议通信 隧道 是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序 3、保存资源的缓存 缓存 是指代理服务器或客户端本地磁盘内保存的资源副本； 即便缓存服务器内有缓存，也会因为客户端的要求、缓存的有效期等因素，向源服务器确认资源的有效性 5、HTTP 首部 HTTP 报文由 HTTP 版本、状态码（数字和原因短语）、HTTP 首部字段 3 部分构成。 {height&#x3D;”278”width&#x3D;”580”} 然后是一些关于 http 字段的解释以及使用 6、确保 HTTP 安全的 HTTPS 1、HTTP 有一些缺点 ： 通信使用明文，内容可能会被窃听； 不验证通信方的身份，因此有可能遭遇伪装； 无法证明报文的完整性，所有有可能已遭篡改 TCP/IP是可能被窃听的网络 加密防止被窃听： 通信的加密---通过和 SSL（安全套接层）或 TLS（安全层传输协议）的组合使用，加密 HTTP 的通信内容 与SSL组合使用的HTTP被称为HTTPS或HTTP over SSL 内容的加密--- 2、 HTTP + 加密 + 认证 + 完整性保护 &#x3D; HTTPS HTTPS 并非一种应用层的新协议；只是 HTTP 通信接口部分用 SSL 和 TLS 协议代替而已； SSL是独立于HTTP的协议，所以其他运行在应用层的SMTP和Telnet等协议均可配合SSL协议使用； SSL 采用一种公开密钥加密的加密处理方式 3、 加密方法 公开加密使用一对非对称的密钥：私有密钥和公有密钥；发送时使用公有密钥加密传送，收到后使用私有密钥解密 4、 证明公开密钥正确性的证书 为了是公开密钥是货真价实的，使用由数字证书认证机构和其相关机关颁发的公开密钥 多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥。 5、 HTTPS 通信 步骤 1： 客户端 通过发送Client Hello 报文开始 SSL 通信。 报文中包含客户端支持的 SSL的指定版本、加密组件（CipherSuite）列表（所使用的加密算法及密钥长度等）。 步骤 2： [服务器] 可进行SSL 通信时，会[以 Server Hello报文作为应答] 。 和客户端一样，在报文中包含 SSL版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出 来的。 步骤 3： 之后[服务器] [发送 Certificate报文] 。报文中包含公开密钥证书。 步骤 4： 最后 [服务器发送 Server Hello Done报文通知客户端] ，最初阶段的 SSL握手协商部分结束。 步骤 5： SSL 第一次握手结束之后， [客户端以 Client KeyExchange 报文作为回应] 。 报文中包含通信加密中使用的一种被称为Pre-master secret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。 步骤 6： 接着 [客户端继续发送 Change Cipher Spec报文] 。 该报文会提示服务器，在此报文之后的通信会采用Pre-master secret 密钥加密。 步骤 7： [客户端发送 Finished报文] 。 该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。 步骤 8： [服务器同样发送 Change Cipher Spec报文] 。 步骤 9： 服务器同样发送 Finished报文] 。 步骤 10： 服务器和客户端的 Finished 报文交换完毕之后，SSL连接就算建立完成 。当然，通信会受到SSL 的保护。从此处开始进行应用层协议的通信，即发送 HTTP 请求。 步骤 11： 应用层协议通信，即发送 HTTP响应。 步骤 12： [最后由客户端断开连接。断开连接时，发送close_notify报文] 。上图做了一些省略，这步之后再发送TCP FIN 报文来关闭与 TCP 的通信 6、为什么不一直使用 HTTPS 其中一个原因：因为与纯文本通信相比，加密通信会消耗更多的 CPU及内存资源。 7、确认访问用户身份的认证 8、基于 HTTP 的功能追加协议 1、 消除 HTTP 瓶颈的 SPDY HTTP 的瓶颈： 一条连接只可以发送一个请求； 请求只能从客户端开始； 请求&#x2F;响应首部未经压缩就发送； 发送冗长的首部； 可任意选择数据压缩格式 1、 ajax 的解决方法 ajax(异步 JavaScript 和 XML 技术)是一种有效利用 JavaScript 和 DOM 的操作，以达到局部 web 页面替换加载的异步通信手段。 ajax 的核心技术是名为 XMLHttpRequest 的 API；利用 ajax 实时地从服务器获取内容，可能会产生大量的请求，ajax 仍未解决 HTTP 协议本身存在的问题 2、 Comet 的解决方法 通过延时应答，模拟实现服务器端向客户端推送的功能 3、 SPDY 在协议级别消除 HTTP 瓶颈 以会话层的形式加入，控制对数据的流动，但还是采用 HTTP 建立通信连接 使用 SPDY 后，HTTP 协议获得以下额外功能：多路复用流；赋予请求优先级；压缩 HTTP 首部 2、使用浏览器进行全双工通信的 WebSocket 利用 Ajax 和 Comet 技术进行通信可以提升 web 的浏览速度，而 WebSocket 是为了解决 HTTP 瓶颈的一套新的协议和 API WebSocket 协议的主要特点：推送功能；减少通信量； 为实现 WebSocket 通信，在 HTTP 连接建立后，需完成一次握手（handshaking） 3、期盼已久的 HTTP&#x2F;2.0 目前主流的是 HTTP&#x2F;1.0 标准，HTTP&#x2F;2.0 的目标是改善用户在使用 Web 时的速度体验 4、Web 服务器管理文件的 WebDAV WebDAV 内新增的方法及状态码 9、构建 Web 内容的技术 1、HTML 2、 动态的 HTML 所谓动态 API，即用客户端脚本语言将静态 HTML 变为动态 HTML DOM 是用以操作 HTML 文档和 XML 文档的 API 3、与 Web 服务器及程序协作的CGI（通用网关接口） CGI 是指 Web 服务器在接收客户端发送过来的请求后转发给程序的一组机制 4、因 java 普及的 ervlet Servlet 是一种能在服务器上创造动态内容的程序 之前提及的 CGI，由于每次街接到请求，程序都要跟着启动一次，因此一旦访问量过大，Web 服务器要承担相当大的负载。 Servlet作作为解决 CGI 问题的对抗技术，Servlet 的运行环境叫做 Web 容器或 Servlet 容器 5、 数据发布的格式和语言 XML（可扩展标记语言）和 HTML 都是从标准通用标记语言 SGML 简化而成 发布更新信息的 RSS&#x2F;Atom JavaScript 衍生的轻量级易用 JSON 10、Web 的攻击技术 1、针对 Web 的攻击技术 2、因输出值转义不完全引发的安全漏洞 3、因设置或设计上的缺陷引发的安全漏洞 4、因会话管理疏忽引发的安全漏洞 5、其他安全漏洞","categories":[{"name":"Font-end","slug":"Font-end","permalink":"https://jiangjingscom.github.io/categories/Font-end/"}],"tags":[{"name":"Program","slug":"Program","permalink":"https://jiangjingscom.github.io/tags/Program/"}]},{"title":"DNS","date":"2018-04-01T14:16:04.000Z","path":"2018/04/01/20180401/","text":"学习了一下 DNS，做个记录。 DNS，域名解析协议。通过 DNS 将人类容易记住的域名解析为互联网中用于通信的 IP。解析时，计算机会优先解析本地的 hosts 文件，有则直接使用，没有则从网络上获取。 查询过程 1、客户机（PC）向首选 DNS 服务器发起请求：”你知道www.benet.com的IP吗？“如果首选DNS服务器知道（一般如果首选DNS服务器曾经解析过，那么会进行一段时间内的缓存，默认三天，如果正好在缓存时间内，那么首选服务器就会知道这个域名的IP），那么首选DNS 服务器就会直接给客户机返回域名的 IP 地址 2、若首选 DNS 服务器上没有相关信息，就不能直接返回域名的 IP 地址，这时候，首选 DNS 服务器就会去询问根 DNS 服务器（所有的 DNS 服务器都知道全球的 13 台 DNS 根服务器在哪里），根服务器可能不知道这个具体的 www.benet.com 的 IP 地址，但是它知道一级域 com 的 IP（也就是说根服务器只负责维护所有的一级域，所以也就几百条数据在这里，虽然数据量少，但是它接受来自全球的请求，所以负载也很大） 3、根服务器将 com 的 IP 地址返回给 首选 DNS 服务器 4、首选 DNS 服务器再去请求 “com” DNS 服务器：”你知道 www.benet.com的IP吗“，但是com DNS 服务器也不知道 www.benet.com 的 IP，但是 com DNS 服务器知道 benet.com 的 IP， 5、”com“DNS 服务器将这个信息返回给 首选 DNS 服务器 6、首选 DNS 服务器再去请求 “benet.com” DNS 服务器，这时候 benet.com 服务器当然就会知道 www.benet.com的IP地址 7、”benet.com“DNS 服务器将这个信息返回给首选 DNS 服务器 8、首选 DNS 服务器将获取到的 www.benet.com的IP返回给客户机 9、客户机根据获取到的www.benet.com 的 IP 地址来访问 WEB 服务器 10、WEB 服务器返回相关的数据","categories":[{"name":"Font-end","slug":"Font-end","permalink":"https://jiangjingscom.github.io/categories/Font-end/"}],"tags":[{"name":"Program","slug":"Program","permalink":"https://jiangjingscom.github.io/tags/Program/"}]},{"title":"《网络是怎样连接的》笔记","date":"2018-03-29T12:34:02.000Z","path":"2018/03/29/20180329/","text":"《网络是怎样连接的》笔记 [Web 浏览器--浏览器生成消息] 浏览器、web 服务器、网址（URL）、HTTP、HTML、协议、URI、请求消息、解析器、Socket 库、DNS 服务器、域名 [生成 HTTP 请求消息] 输入网址 -&gt; 解析 URL -&gt; 确定 web 服务器和文件名 -&gt; 生成 HTTP 请求消息 请求消息：请求行+消息头+消息体 响应消息：状态行+消息头+消息体 [向 DNS 服务器查询 web 服务器的 IP 地址] 1、IP 地址是一串 32 比特的数字，8 比特一组分为 4 组。分别用十进制表示再用圆点隔开。 2、子网掩码格式与 IP 类似。左边一半都是 1，右边一半都是 0.子网掩码为 1 的部分表示网络号，子网掩码为 0 的部分表示主机号。主机号全 0 表示整个子网，全 1 表示向子网所有设备发送包，即广播。 3、通过 DNS 查询 IP 地址的操作称为域名解析，计算机上的这一解析器包含在操作系统的 Socket 库中。Socket库是用于调用网络功能的程序组件集合。 [DNS 服务器工作] 1、DNS 服务器会从域名与 IP 地址的对照表中查找相应的记录，并返回 IP 地址。 2、DNS服务器中的所有信息都是按照域名以分层次的结构来保存的，一个域的信息是作为一个整体存放在DNS 服务器中的，可以通过创建下级的域来分配给不同的服务器。 [委托协议栈发送消息] 向操作系统内部的协议栈发出委托时，需要按照指定的顺序来调 用 Socket库中的程序组件。 创建套接字(创建套接字阶段) 将管道连接到服务器端的套接字上(连接阶段) 收发数据(通信阶段) 断开管道并删除套接字(断开阶段) [协议栈、网卡—用电信号传输 TCP&#x2F;IP 数据] TCP&#x2F;IP、套接字、协议栈、IP 地址、端口号、包、头部、网卡、网卡驱动、MAC 地址、以太网控制器、ICMP、UDP [创建套接字] 1、协议栈的内部结构 应用程序（浏览器、电子邮件客户端、web 服务器、电子邮件服务器）—&gt; Socket 库（包括解析器） 操作系统内部（包括协议栈）。协议栈上半部分（TCP&#x2F;UDP），接受应用程序的委托执行收发数据的操作，像浏览器、邮件等一般的应用程序都是使用 TCP 收发数据的，而像 DNS 查询 等收发较短的控制数据的时候则使用 UDP；协议栈下半部分（IP），IP 中还包括 ICMPA 协议和 ARPB 协议。 ICMP 用于告知网络包传送过程中产生的错误以及各种控制消息，ARP 用 于根据 IP 地址查询相应的以太网 MAC 地址 网卡驱动程序。负责控制网卡硬件 网卡。负责完成实际的收发操作，也就是对网线中的信号执行发送和接收的操作。 2、套接字的实体就是通信控制信息 在 Windows 中可以用 netstat命令显示套接字内容，协议栈是根据套接字中记录的控制信息来工作的。 3、调用 socket 时的操作 应用程序调用 socket 申请创建套接字，协议栈根据应用程序的申请执行创建套接字的操作 创建套接字时，首先分配一个套接字所需的内存空间，然后向其中写入初始状态。 [连接服务器] 创建套接字之后，应用程序(浏览器)就会调用 connect，随后协议栈会将本地的套接字与服务器的套接字进行连接 1、负责保存控制信息的头部 控制信息可以分为两类，第一类是客户端和服务器相互联络时交换的控制信息；另一类，是保存在套接字中，用来控制协议栈操作的信息 2、连接操作的实际过程 [收发数据] 当控制流程从 connect 回到应用程序之后，接下来就进入数据收发阶段了 1、将 HTTP 请求消息交给协议栈 数据收发操作是从应用程序调用 write 将要发送的数据交给协议栈开始的，协议栈收到数据后将数据存放在内部的发送缓冲区中，在数据积累到一定量（MTU、MSS）时再发送出去。 像浏览器这种会话型的应用程序在向服务器发送数据时，等待填满缓冲区导致延迟会产生很大影响，因此一般会使用直接发送的选项。 2、对较大的数据进行拆分 3、使用 ACK 号确认网络包已收到 通过”序号”和”ACK 号”可以确认接收方是否收到了网络包。 4、根据网络包平均往返时间调整 ACK 号等待时间 TCP 采用了动态调整等待时间的方法，这个等待时间是根据 ACK 号返回所需的时间来判断的。具体来说，TCP 会在发送数据 的过程中持续测量 ACK 号的返回时间，如果 ACK 号返回变慢，则相应延长等待时间;相对地，如果 ACK 号马上就能返回，则相应缩短等待时间 。 5、使用窗口有效管理 ACK 号 6、[ACK 与窗口的合并] 7、接收 HTTP 响应消息 首先，浏览器在委托协议栈发送请求消息之后，会调用 read 程序来获取响应消息。然后控制流程会通过 read 转移到协议栈，协议栈会执行接下来的操作。和发送数据一样，接收数据也需要将数据暂存到接收缓冲区中。首先，协议栈尝试从接收缓冲区中取出数据并传递给应用程序，但这个时候请求消息刚刚发送出去，响应消息可能还没返回。响应消息的返回还需要等待一段时间，因此这时接收缓冲区中并没有数据，那么接收数据的操作也就无法继续。这时，协议栈会将应用程序的委托，也就是从接收缓冲区中取出数据并传递给应用程序的工作暂时挂起，等服务器返回的响应消息到达之后再继续执行接收操作。 首先，协议栈会检查收到的数据块和 TCP 头部的内容，判断是否有数据丢失，如果没有问题则返回 ACK 号。然后协议栈将数据块暂存到接收缓冲区中，并将数据块按顺序连接起来还原出原始的数据，最后将数据交给应用程序。具体来说，协议栈会将接收到的数据复制到应用程序指定的内存地址中，然后将控制流程交回应用程序。将数据交给应用程序之后，协议栈还需要找到合适的时机向发送方发送窗口更新B。 [从服务器断开并删除套接字] 1、数据发送完毕后断开连接 数据发送完毕的一方会发起断开过程，但不同的应用程序会选择不同的断开时机 以服务器一方发起断开过程为例来进行讲解。首先，服务器一方的应用程序会调用 Socket 库的 close 程序。然后，服务器的协议栈会生成包含断开信息的 TCP 头部，具体来说就是将控制位中的 FIN 比特设为 1。接下来，协议栈会委托 IP 模块向客户端发送数据。同时，服务器的套接字中也会记录下断开操作的相关信息。接下来轮到客户端了。当收到服务器发来的 FIN 为 1 的 TCP 头部时，客户端的协议栈会将自己的套接字标记为进入断开操作状态。然后，为了告知服务器已收到 FIN 为 1 的包，客户端会向服务器返回一个 ACK 号。这些操作完成后，协议栈就可以等待应用程序来取数据了。过了一会儿，应用程序就会调用 read 来读取数据，这时，协议栈会告知应用程序(浏览器)来自服务器的数据已经全部收到了。因此，客户端应用程序会调用 close 来结束数据收发操作，这时客 户端的协议栈也会和服务器一样，生成一个 FIN 比特为 1 的 TCP 包，然后委托 IP 模块发送给服务器。一段时间之后，服务器就会返回 ACK 号。到这里，客户端和服务器的通信就全部结束了。 2、删除套接字 和服务器的通信结束之后，用来通信的套接字并不会立即被删除，而是会等待一段时间之后再被删除，为了防止误操作。 3、数据收发操作小结 创建套接字。 客户端会向服务器发起连接（SYN -&gt; SYN+ACK -&gt; ACK）。 数据收发阶段（Web：序号+数据、ACK、窗口）。 断开操作（Web：FIN -&gt; ACK -&gt; ...FIN -&gt; ...ACK -&gt;套接字被删除） [IP 与以太网的包收发操作] 1、包的基本知识 2、包收发操作概览 3、生成包含接收方 IP 地址的 IP 头部 4、生成以太网用的 MAC 头部 5、通过 ARP 查询目标路由器的 MAC 地址 6、以太网的基本知识 7、将 IP 包转换成电或光信号发送出去 8、给网络包再加 3 个控制数据 9、向集线器发送网络包 10、接收返回包 11、将服务器的响应包从 IP 传递给 TCP [UDP 协议的收发操作] 1、不需要重发的数据用 UDP 发送更高效 UDP 没有 TCP 的接收确认、窗口等机制，因此在收发数据之前也不需要交换控制信息，也就是说不需要建立和断开连接的步骤，只要在从应用程序获取的数据前面加上 UDP 头部，然后交给 IP 进行发送就可以了 2、控制用的短数据 接收也很简单，只要根据 IP 头部中的接收方和发送方 IP 地址， 以及 UDP头部中的接收方和发送方端口号，找到相应的套接字并将数据交给相应的应用程序就可以了 3、音频和视频数据 发送音频和视频数据的时候使用 UDP [集线器、交换机、路由--从网络 到网线设备] 局域网（LAN）、双绞线、串扰、中继式集线器、MDI、MDI-X、交换式集线器、双全工、半双工、碰撞、自动协商、路由器、路由表、子网掩码、默认网关、分片、地址转换、公有地址、私有地址 [接入网、网络运营商--通过接入网进入互联网内部] ADSL、FTTH、光纤、接入网、ADSL、Modern 集成式路由器、ATM、信元、正交振幅调制、分离器、DSLAM、宽带接入服务器、远程接入服务器、PPP、网络运行中心（NOC）、光纤、IX（互联网交换） [防火墙、缓存服务器—服务端的局域网中有什么玄机] 防火墙、包过滤器、数据中心、轮询、负载均衡器、缓存服务器、代理、代理服务器、内容分发服务、重定向 [Web 服务器的部署地点] [防火墙的结构和原理] 1、主流的包过滤方式 包过滤、应用层网关、电路层网关等几种方式 2、如何设置包过滤的规则 3、通过端口号限定应用程序 4、通过控制位判断连接方向 5、从公司内网访问公开区域的规则 6、从外部无法访问公司内网 [通过将请求平均分配给多台服务器来平衡负载] 使用负载均衡器分配访问 [利用缓存服务器分担负载] 1、如何使用缓存服务器 缓存服务器是一台通过代理机制对数据进行缓存的服务器 2、缓存服务器通过更新时间管理内容 3、最原始的代理——正向代理 4、正向代理的改良版——反向代理 5、透明代理 [内容分发服务] 1、利用内容分发服务分担负载 2、如何找到最近的缓存服务器 3、通过重定向服务器分配访问目标 4、缓存的更新方法会影响性能 Web 服务器--请求到达 web 服务器，响应返回浏览器 响应消息、多任务、多线程、虚拟目录、CGL、表单、访问控制、密码、数据格式、MIME 服务器概览 服务器的接收操作 Web 服务器程序解释请求消息并作出响应 浏览器接收响应消息并显示内容","categories":[{"name":"Font-end","slug":"Font-end","permalink":"https://jiangjingscom.github.io/categories/Font-end/"}],"tags":[{"name":"Program","slug":"Program","permalink":"https://jiangjingscom.github.io/tags/Program/"}]},{"title":"《编程语言的核心概念》笔记","date":"2018-03-15T14:20:04.000Z","path":"2018/03/15/20180315/","text":"《编程语言的核心概念》笔记 编程语言的教材中会罗列出各种各样的规则。其实这些规则并不具有普遍意义，只是因为”在当前的特定情况下，做此规定能更方便”。 语言的真假值 学过 C 语言的人都被告知 0 是假，其余为真。 在 Ruby 中，false 和 nil 为假，其余(包括 0 在内)都为真。 Java 语言中，因为 0 为整型而不是真 假值类型，如果在条件语句中用 0作判断条件，就要发生编译错误。 程序设计语言诞生的历史 1946 年，世界上第一台电子计算机——ENIAC(埃尼阿克，ElectronicNumerical Integrator andComputer)问世。它可以改变计算方式，即可以更改程序。它是一台可编程计算机。 1949 年，EDSAC(爱达赛克，Electronic Delay Storage AutomaticCalculator，电子延迟存储自动计算机)问世。这是一种通过纸带打孔的方式来记录和读取数据的计算机 1954 年，与大家现在使用的语言类似的程序设计语言才被发明出来。这就是FORTRAN。它的全称是 Formula Translating System(公 式翻译系统) 程序设计语言产生的原因 我们为了获得更轻松便捷的体验而编写程序。Perl 语言的设计者 Larry Wall在其著作 Programming Perl 中提出，优秀的程序员具有三大美德:懒惰、急躁和傲慢(Laziness, Impatience and Hubris)。这就是俗称的程序员的三大美德。 语言们各有各的便捷 C++ 是一种非常重视代码执行速度的语言。为了使编程实现相同目的时，执行速度不亚于 C 语言，C++ 语言的规范相应变得复杂了。 Scheme 是一种很重视语言规则是否容易掌握的编程语言。它追求语言规范最简原则，所以它的语言规范全部加起来只有紧凑的 50页（第五版修订版是 50 页，2007 年 的第六版增加到 187 页）而已 。 Python 是一种侧重于把代码阅读变得容易的语言。 用 PHP 语言编写 Web 服务很轻 松，但它不擅长文字处理。 Haskell 和 OCaml 这样的 ML(Meta-Language)系列语言，编写处理语言文字的应用很便捷，但编写 Web 服务时就没有 PHP 使用得那么多了 语法的诞生 语言设计者制定的规则就是语法。语法因语言而异。 比如 C 语言中的赋值符&#x3D;是运算符。但它与普通的加减乘除运算符不同，是右结合运算符。所以源代码中 X &#x3D; Y &#x3D; 1 这样的语句，被解释为 X&#x3D;(Y&#x3D;1)。与这不同的是，Python语言中的赋值符&#x3D;不是运算符而是一种句式，在运算式中不能出现。 FORTH 语言开发于 1958年左右，是一种几乎没有语法的语言。作为其一大特点，FORTH语言使用了被称为栈的数值预存空间。1 加 2 再乘以 3 可以表达为：1 2+ 3 *。2 乘 3 再加 1 可以表达为：23*1 +。基本上与日语中的语序是一致的。FORTH 语言不需要使用括号或者优先次序就可以表达计算顺序 Java、Python、 Ruby 1.9 这些语言使用了栈机器型的 VM。VM执行的命令行和 FORTH 语言是一样的。 LISP 语言（1958 年诞生）则需要用括号标示完整的意思单元。表达 1 与 2相加的结果与 3 相乘： (* (+ 1 2) 3) 语法分析器是把源代码作为字符串读入、解析，并建立语法树的程序。 程序的流程控制 if 语句诞生 while 语句通过条件判断来控制循环操作 for 语句通过循环次数来 控制循环操作 foreach 句型则是通过处理的对象来控制循环操作 函数的诞生 把反复使用的命令封装在一起再利用，这种需求在很早以前就有了 1949 年的 EDSAC 就使用了带有这一功能的技术。当时，程序的命令和数据完全都存储在内存中，修改程序就如同把数值代入变量中一样简单。通过修改程序中跳转命令的跳转目的地，就能使函数调用后返回原来的位置 。 创建用来事先记录返回目的地的内存空间，并设计能跳转到该内存空间里记录的地址的命令。这样，即使函数调用前不知道返回命令所在地也没关系了。这种方法也有一个问题。当调用函数X 期间又调用了函数 Y 时，返回目的地内存被写覆盖，栈于是登场了。 递归调用，是指函数内部再次调用当前函数的过程。使用了递归调用的程序，也可以不用递归调用来实现 。 错误处理 错误处理的方法大体可分为两种:使用返回值和使用异常(异常处理)。 错误发生时跳转这一想法的产生甚至比程序设计语言的产生还要早。1950 年设计的计算机 UNIVACI 中就有了这样的功能，在计算中出现溢出时，它会执行在 000处编写的命令。这种功能被称为”中断”(interrupt)，广泛被运用于错误处理等各领域中。 到 1964 年 PL&#x2F;I 语言诞生时，很多对当今的异常处理意义重大的特征已经被提出来了，如允许定义出错时的处理操作，可以追加新的错误类型，可以自主触发出错等。 1975 年，John Goodenough 在自己的论文 A 中提出了一种更好的异常处理的方法。为使编译器能够对程序员的错误发出警告，减少这种可能性，需要做到两点。一是明确声明命令可能抛出何种异常，二是需要有将可能出错的操作括起来的语句结构。 1983 年，C++ 语言诞生。针对异常处理的语句结构问题 从 1984 年到 1989年间经历了多次讨论，C++ 语言最终确认追加一 种语句结构，把关键字 try放在那些被括起来的可能出错代码的前 面，把关键字 catch放在捕捉并处理错误的代码块前面 。 何时抛出异常 函数调用时参数不足的情况。比如，调用一个带有两个参数的函数但只传递一个参数时会发生什么? Python 语言和 Ruby 语言会在函数调用的时刻抛出异常。但是 JavaScript 语言会把缺失的参数当作未定义的特殊值(undefined)继续执行。 数组越界的情况。比如，试图读取一个只有三个数的数组的第四个数值时会怎么样?这就是数组的界外操作。此时，Python 语言会抛出异常，Ruby 语言会返回一个指示不存在的特殊值(nil)，而 JavaScript 语言会返回 undefined。 名字和作用域 作用域是指名字的有效范围。要保证程序整体不会出现名字冲突是件困难的事情，为此将名字的有效范围限定在更小的范围之内，让程序管理变得轻松一些。 动态作用域和静态作用域 1958 年问世的早期 LISP 语言是动态作用域。 1975 年问世的作为 LISP 语言的一种的 Scheme 语言采用了静态作用域。 1994 年问世的 JavaScript 语言和 Perl 语言一样，把没有任何声明的变量视为全局作用域，把用 var 声明的变量视为静态作用域。 而 1991 年问世的 Python 语言和 1995 年问世的 Ruby中，即使不带任何修饰的变量也被视为 静态作用域。 类型 C++ 语言的设计者本贾尼·斯特劳斯特卢普把用户能自定义的类型当作构造程序的基本要素，把这种类型冠名为类。这就是第二次面向对象的发明 将类型即功能的观念进一步延伸，就产生了不包含有具体的实现细节的类型(Java 语言中的接口等)。 通过将不同类型进行组合得到复杂的类型后，使用中会出现想更改其中一部分却又不想全部重新定义的再利用需求。因此出现了构成要素部分可变的类型，即总称型。想要表现不同的情况时，出现了以类型为参数创建类型的函数。C++语言中的模板、 Java 语言中的泛型以及 Haskell语言中的类型构造器可以说就是这种创 建类型的机制 。 把类型的信息和数值看作整体的方式叫动态类型。比如使用了动态类型的脚本语言之一的Python 语言中，变量声明时不需要声明类型，对同一个变量既可以赋值整数也可以赋值浮点数。 类型推断。Haskell 语言的类型推断。Scala 语言的类型推断 容器和字符串 容器的名称不同，性质各异。比如，C 语言中的 数组、LISP语言中的列表、Python 语言中的元组以及 Ruby 语言中的数组。即使是名字相同，在不同语言中表达的意思也可能不一样。比如， LISP语言和 Haskell 语言中的列表，与 Java 语言和 Python 语言中的列表在内部构造上完全不同。 比较两种容器，一种是数组，另一种是链表。 数组在内存中的存储方式是连续的，大前提就是要有连续的内存区域。而链表却没有这一要求，它可以使用零散细分的内存区域。 在 Java、Python、Ruby等语言中都将数组作为一种最基本的容器标准。与此相对应，在LISP、Scheme、Haskell 等语言中都将链表作为一 种最基本的容器。 另一种诸多语言都支持的容器，它被称作字典、散列 或关联数组等 散列表使用以字符串为参数返回整数的散列函数，实现了字符串与值的对应。 字符集和字符的编码方式。 摩斯码用短时间接通的短点和是其 3 倍时长的接通的长点的组合来表达字符。 博多码的特征是，一个字符由 5 个通与断(5 比特)的组合来表现。ASCII中，1 个字符用 7 个比特进行编码。7 个比特可以表达 128 个字符。 并发处理 竞态条件成立的三个条件 两个处理共享变量 至少一个处理会对变量进行修改 一个处理未完成之前另一个处理有可能介入进来规避竞态 UNIX将执行的程序叫做进程(process)。不同的进程不会共享内存，所以在多个程序之间不会在内存上出现竞态条件。 在不共享内存的设计方针下，还有一个流派——actor 模型。它发布 于1973 年，是为实现并发处理而出现的一种模型。ErlangB、Scala 等 actor模型的语言在消息交互的场景发挥着作用。 有一种方法是通过规避条件二，即使共享内存，只要不作修改也不会有任何问题。Haskell语言就是一种大力提倡这种方针的语言，它的所有变量都不 可修改。 还可以消除竞态条件成立的第三个条件，不介入。表示不便介入的标志——锁、mutex、semaphore 锁的问题及对策 借助事务内存来解决。这种方法把数据库中事务的理念运用到内存上，做法是先试着执行，如果失败则回退到最初状态重新执行，如果成功则共享这一变更。 对象与类 模块、包 1978 年左右开发出来的 Modula-2 导入了模块的概念，显示地表达了这种关联性强的几个函数和变量的组合。至今很多编程语言都延续了这个机制。Python 语言和 Ruby 语言继续把它称为模块，而 Java 语言和Perl 语言则把它称为包 闭包 为什么把这称为闭包?一个包含了自由变量的开放表达式，它和该自由变量的约束环境组合在一起后，实现了一种封闭的状态。 类 C++ 语言中类的概念是以 Simula 这种仿真用语言 B中的类为参考，方便用户定义类型(type)而设计出来的。斯特劳斯特卢普是这样解释的:类是类型。这是 C++语言中极为重要的一种思想。既然C++语言中类的意思就是用户定义的类型，那为什么不把它叫做type 呢?我之所以选择使用class，是因为实在不喜欢不断地创造新词，才选用 Simula 语言中 class这个谁都不至于困惑的词。 继承与代码再利用 继承的不同实现策略 一般化与专门化。第一种策略是在父类中实现那些一般化的功能，在子类中实现那些专门的个性化的功能。其设计方针就是子类是父类的专门化。 共享部分的提取。第二种策略是从多个类中提取出共享部分作为父类，对于子类是否为父类的一种，它的答案是否定的。这种提取出共享部分的设计方针是习惯了函数的一种考虑问题的方法。 差异实现。第三种策略认为继承之后仅实现有变更的那些属性会带来效率的提高，它把继承作为实现方式再利用的途径，旨在使编程实现更加轻松。 多重继承的问题——还是有冲突 解决方法 1:禁止多重继承。Java 语言中就禁止了类的多重继承。除此之外，在 Java 语言及其相关库中也可以观察到舍弃作为实现方式再利用的继承的倾向。取而代之发展起来的概念是委托，这种方法定义了具有待使用实现方式的类的对象，然后根据需要使用该对象来处理。Java语言中禁止了多重继承，但它也具备实现多重继承的功能。这就需要借助接口。接口是没有实现方式的类。它的功能仅仅在于说明继承了该接口的类必须持有某某名字的方法。 解决方法 2:按顺序进行搜索。 解决方法 3:混入式处理 解决方法 4:Trait","categories":[{"name":"Others","slug":"Others","permalink":"https://jiangjingscom.github.io/categories/Others/"}],"tags":[{"name":"Program","slug":"Program","permalink":"https://jiangjingscom.github.io/tags/Program/"}]},{"title":"《Java从入门到精通》笔记","date":"2017-12-23T15:12:12.000Z","path":"2017/12/23/20171223/","text":"《Java 从入门到精通》笔记 基本概念： 1、java 历史 –1995 年 Oak 改名为 java，2006 年发布 JRE6.0 2、简单的 java 程序 –关键字、标识符 3、Eclipse 安装 4、常量、变量、数据类型、运算符、表达式、语句、程序结构、数组 类型转换原则： 1、占用字节少的类型转换成占用字节较多的类型 2、字符类型转换成 int 类型 3、int 类型会转换成 float 类型 4、表达式中若某个操作数的类型为 double，则另一个操作数也会转换成 double 类型 5、布尔类型不会转换成其他类型 核心技术： 1、类和对象–类的声明和定义、对象的声明和使用 1、过程式编程语言：程序&#x3D;算法+数据 面向对象编程语言：程序&#x3D;对象+消息 2、 “&#x3D;&#x3D;”用于比较两个对象的内存地址是否相等 equals()用于比较两个对象的内容是否一致 3、类的属性 定义规则： 1、类的属性是变量 2、类的属性的类型可以是基本类型，也可以是引用类型 3、类的属性的命名规则，驼峰 一些规则： 1、静态内部类可以定义静态方法、非静态方法、静态属性、静态内部类、非静态内部类 2、非静态内部类不能定义静态属性、可以定义静态常量属性、不能定义静态方法、不能定义静态内部类 类变量和成员变量的区别： 1、类变量就是 static 修饰的变量，它们被实例所共享，一个实例改变了这个值，其他实例也会受到影响 2、成员变量是实例私有的，只有实例本身可以改变它的值 4、类的方法 –方法的定义和使用，构造方法的重载和私有 1、java 中，构造方法所完成的主要工作是帮助新创建的对象赋初值 2、 构造方法的使用：它与类名具有相同的名称，它没有返回值，它在创建对象时自动调用；如果构造方法设为 private，则无法再该构造方法所在的类以外的地方被调用 3、如果类中没有声明构造方法，那么程序会自动生成一个无参的构造方法，若是声明了构造方法，那么默认的构造方法不会自动声明。且类中必须要有无参的构造方法。 2、类的封装、继承与多态 –面向对象程序设计的三个主要特征 1、继承 extends，java 继承只能继承父类的公有属性和公有方法，而隐含的继承了私有属性。 2、java 中只允许单继承，而不允许多重继承，即一个子类只能有一个父类。但在 java 中允许多层继承 3、子类对象在实例化时会默认先去调用父类中的无参构造方法，之后再调用本类中相应构造方法 4、用 super 调用父类中的构造方法，只能放在程序的第一行；super 也可以调用父类中的属性或方法 5、多态是指允许程序中出现重名现象，含有方法重载和成员覆写两种多态 1、 方法重载是指，在一个类中，允许多个方法使用同一个名字，但方法参数不同；（方法名称相同，却可以在不同场合做不同的事） 2、 成员覆写是指，子类与父类具有相同的变量名称，数据类型不同，允许具有相同的方法名称，但完成的功能不同。 当一个子类继承一个父类，而子类中的方法与父类中的方法的名称、参数个数、类型等完全一致时，就称子类中的这个方法覆写了父类中的方法； 同理，如果子类中重复定义了父类中已有的属性，则称此子类中的属性覆写了父类中的属性。 3、 向上转型 ，例如父类对象通过子类对象去实例化；自动完成，会丢失精度 4、 向下转型，例如父类对象可以转换为子类对象；必须进行强制类型转换；不是所有的父类对象都可以强制转换成子类对象 3、抽象类与接口 抽象类的定义规则：abstract class 类名称 1、抽象类和抽象方法都必须用 abstract 关键字来修饰 2、抽象类不能直接实例化，即不能直接用 new 关键字去产生对象 3、抽象方法只需声明，而不需实现 4、含有抽象方法的类必须声明为抽象类，抽象类的子类必须覆写所有的抽象方法后才能被实例化，否则这个子类还是个抽象类 在抽象定义的语法中，方法的定义分为：一般方法与抽象方法； 抽象方法是以关键字 abstract 为开头的方法，此方法只声明返回值的数据类型、方法名称与所需的参数，但没有定义方法体。 接口： interface 接口名称 其 结构与抽象类非常类似，也具有数据成员与抽象方法，但与抽象类有以下两点不同。 1、接口里的数据成员必须初始化，且数据成员均为常量。 2、接口里的方法必须全部声明为 abstract，也就是说，接口不能像抽象类一样保有一般的方法，必须全部都是抽象方法 接口是用于实现 多继承（一个类只能继承一个父类，却可以实现多个接口）的一种机制，每个由接口实现的类必须在类内部覆写接口中的抽象方法，且可以自由使用接口中的常量；利用接口打造新的类的过程，称之为接口的实现。 4、关于类的专题研究 内部类：在类内部定义的另一个类，可声明为 public 或 peivate 1、用 static 声明的内部类不能访问非 static 声明的外部类属性 2、将内部类声明为 public，则内部类也可以通过创建对象从外部类之外被调用 3、在方法中定义的内部类只能访问方法中的 final 类型的局部变量 4、匿名内部类 方法： 1、在 static 方法内只能访问到 static 成员变量（包括数据成员和方法成员） 2、方法的重载：在同一个类中允许同时存在一个以上的同名的方法，只要它们的参数个数或类型不同即可 接口对象的实例化 1、接口中没有构造方法，接口是无法实例化的，只能通过其子类进行实例化 this 关键字的使用 this 表示当前对象，this()调用无参构造方法 static 关键字的使用 static 既可以声明变量，也可以声明方法，用它声明的方法有时被称为‘类方法’ 如果在类中声明一个 static 类型的属性，则此属性既可以在非 static 类型方法中使用，也可以在非 static 类型的方法中使用。 但若要用 static 类型的方法调用非 static 类型的属性，就会出现错误。 理解 main()方法 1、由于 java 虚拟机必须要调用类的 main()方法，所以该方法的访问权限必须是 public 2、又因为 java 虚拟机在执行 main 方法时不必创建对象，所有该方法必须是 static 的 3、该方法接收一个 String 类型的数组参数，该数组中保存执行 java 命令时传递给所运行类的参数 静态代码块 当类被载入时，静态代码块被执行，且只执行一次，静态代码块经常用于进行类属性的初始化 final 关键字的使用 1、final 标记的类不能被继承 2、final 标记的方法不能被子类覆写 3、final 标记的变量（成员变量或局部变量）即为常量，只能赋值一次 5、java 常用类库 即 java API String 类和 StringBuffer 类 1、这两个类封装了对字符串的各种操作，它们都被放在 java.lang 包中，不需要导入该包就可以直接使用 2、String 类用于比较两个字符串，查找和抽取串中的字符或子串，进行字符串与其他类型之间的互相转换等。String 类对象的内容一旦被初始化就不能被改变 3、StringBuffer 类用于内容可以被改变的字符串，可以将其他各种类型的数据增加，插入到字符串中，也可以转置字符串中原来的内容 基本数据类型的包装类 Integer、Character、Float、Double、Byte、Long、Short、Boolean System 类和 Runtime 类 1、java 不支持全局方法和变量，java 设计者将一些系统相关的重要方法和变量收集到统一的类中，就是 System 类。System 类中所欲的成员都是静态的，要引用这些方法，可直接使用 System 类名作为前缀 2、Runtime 类封装了 java 命令本身的运行进程。不能直接创建 Runtime 实例，但可以通过静态方法 Runtime.getRuntime 获得正在运行的 Runtime 对象的引用 Date 与 Calendar。DateFormat 类 1、Date 类表示日期和时间。开始设计 Date 类时没有考虑到国际化，因此又设计了两个类 Calandar、DateFormat 2、Calandar 类是一个抽象基类，主要完成日期字段之间相互操作的功能 Math 与 Random 类 1、Math 类包含了所有用于几何和三角的浮点运算方法，这些方法都是静态的 2、Random 类是一个随机数产生器 hashCode()方法 在用于存取散列表的时候使用，只要保证对象不同有不同的散列码 对象克隆 6、包的访问权限 基本概念 在类或接口的最上面一行加上 package 声明，同一个文件内的接口或类就都会被纳入相同的 package 中 用 import 语句可以导入 package，若某个类需要被访问，则必须把这个类公开出来。 JDK 中的常见包 java.lang 一些 java 语言的核心类，如 String、Math、Integer、System 和 Thread java.awt 包含构成抽象窗口工具集的多个类 avaw.swing 包含构建图形用户界面 java.applet 包含 applet 运行所需要的类 java.net 包含执行与网络相关的操作类 java.io 包含能提供多种输入&#x2F;输出功能的类 java.util 包含一些工具类，如定义系统特性、与日期日历相关的方法 类成员的访问控制权限 java 有四种访问控制权限：private、default、protected、public 1、private 如果一个成员方法或成员变量名的前面使用了 private 访问控制符，那么这个成员只能在这个类的内部使用 不能在方法体内声明的变量前面加 private 修饰符 2、default 如果一个成员或成员变量前面没有使用任何访问控制符，就称这个成员所拥有的是默认（default）访问控制符 默认访问控制成员可以被这个包中的其他类访问，如果子类与父类不在一个包中，子类不能访问父类中的默认访问控制成员 3、protected 如果一个成员方法或成员变量名的前面使用了 protected 访问控制符，那么这个成员既可以被同一个包中的其他类访问，又可以被不同包中的子类访问 4、public 如果一个成员方法或成员变量名的前面使用了 public 访问控制符，那么这个成员可以被所有的类访问，不管访问类与被访问类是否在同一个包中 java 的命名习惯 1、包中的名字一律小写 2、类名、接口应当使用名词，每个词首字母大写 3、变量名（属性名）第一个单词小写，后面的每个单词首字母大写 4、方法名的第一个单词小写，后面的每个单词首字母大写 5、常量名的每个字母一律大写 7、异常处理 基本概念 1、算数异常 2、没有给对象开辟内存空间时会出现空指针异常 3、找不到文件异常 异常可以分为两大类， java.lang.Exception 和 java.lang.Error，它们均继承自 java.lang.Throwable 类 编写自己的 异常类 class 异常名 extends Exception 8、java 类集框架 类集接口 1、Collection 接口 是构造类集框架的基础 2、List 接口 扩展了 Collection 并声明存储一系列元素的类集特性 3、集合接口 扩展了 Collection 并说明了不允许复制元素的类集的特性 4、SortedSet 接口 扩展了 Set 并说明了按升序排列的集合的特性 Collection 接口 1、ArrayList 类 扩展 AbstractList 并执行 List 接口，ArrayList 支持可随需要而增长的动态数组 2、LinkedList 类 扩展了 AbstractSequentialList 类并实现 List 接口，它提供了一个链接列表的数据结构 3、HashSet 类 扩展了 AbstractSet 并且实现 Set 接口，它创建了一个类集，该类集使用散列表进行存储，而散列表则通过使用称之为散列法的机制来存储信息。 4、TreeSet 类 为使用树来进行存储的 Set 接口提供了一个工具，对象按升序存储 通过迭代方法访问类集 通过迭代方法访问类集之前，每一个 Collection 类都提供一个 iterator 方法，该方法返回一个对类集的迭代方法。 通过使用这个迭代对象，可以一次一个地址访问类集中的每一个元素。 处理映射 映射（map）是一个存储关键字和值的关联，或者说‘关键字&#x2F;值’对的对象 1、映射接口 Map 接口 SortedMap 接口 扩展了 Map，它确保了各项按关键字升序排序 2、映射类 HashMap 类 使用散列表实现 Map 接口 TreeMap 类 通过树实现 Map 接口 9、多线程 进程与线程 1、进程的特征： （1）一个进程就是一个执行中的程序，而每个程序都有自己独立的一块内存空间，一组系统资源。在进程概念中，每个进程的内部数据和状态都是完全独立的 （2）创建并执行一个进程的系统开销是比较大的 （3）进程是程序的一次执行过程，是系统运行程序的基本单位 2、线程的特征 （1）在 java 中，程序中通过流控制程序流。程序中单个顺序的流控制称为线程 （2）多线程指的是在单个进程中可以同时运行多个不同的程序，执行不同的任务。多线程意味着一个程序的多行语句可以看上去几乎同时运行。 二者都是一段完成某个特定功能的代码，是程序单个顺序的流控制 通过继承 Thread 类实现多线程 Thread 类实现了 Runnable 接口 1、一个类继承 Thread 类之后，这个类的对象无论调用多少次 start()方法，结果都只有一个线程运行。即一个线程对象只启动一次 2、用 Thread 类实际上无法达到资源共享的目的 通过实现 Runnable 接口实现多线程 1、适合多个相同程序代码的线程去处同一资源的情况，把虚拟 CPU（线程）同程序的代码、数据有限分离。 2、可以避免由于 java 的单继承特性带来的局限。 3、增强了程序的健壮性，代码能够被多个线程共享，代码与数据是独立的。 线程的状态 五种 1、NEW 创建 2、RUNNABLE 正在 java 虚拟机中执行 3、BLOCKED 受阻塞并等待某个监视器锁 4、WAITING 无限期等待另一个线程来执行某个特定操作 5、EIMED_WAITING 等待另一个线程来执行取决于指定等待时间的操作 6、TERMINATED 已退出的线程 线程的一些操作方法 1、取得和设置线程名称 getName() setName() 2、判断线程是否启动 isAlive() 3、后台线程 setDaemon() 4、线程的强制运行 join() 5、线程的休眠 sleep() 6、线程的中断 interrupt() 多线程的同步 1、同步代码块 synchronized() 2、死锁 一旦有多个进程，且它们都要争用对多个锁的独占空间，就可能发生死锁 有过有一组进程或线程，其中每一个都在等待一个只有其他进程或线程才可以进行的操作，则死锁了 线程间的通信 wait：告诉当前线程放弃监视器并进入睡眠状态，直到其他线程进入同一监视器并调用 notify 为止。 notify：唤醒 同一对象监视器中调用 wait 的第 1 线程 notifyAll：唤醒同一对象监视器中调用 wait 的所有线程 wait、notify、notifyAll 这三个方法只能在 synchronized 方法中调用，即无论线程调用一个对象的 wait 还是 notify 方法，该线程必须先得到该对象的锁标记。 线程生命周期控制 通过控制 run 方法中循环条件的方式来结束一个线程的方法是值得推荐使用的方法。 10、文件 IO 操作 File 类 File 类是 IO 包中唯一代表磁盘文件本身的对象。 通过调用 File 类提供的方法，能够完成创建、删除文件、重命名文件、判断文件的读写权限及文件是否存在，设置和查询文件的最近修改时间等操作。 getName()方法用于返回文件名 getParent()方法用于返回父目录名 exists()方法在文件存在的情况下返回 true，反之放回 false File 类是不对称的，没有相应的方法来改变这些属性。 RandomAccessFile 类 是 java 语言中功能最为丰富的文件访问类 流类 1、java 的输入输出建立在 4 个抽象类的基础上，它们用于创建具体流式子类。 InputStream 字节流类（处理字节或二进制对象） OutputStream 字节流类 Reader 字符流类（处理字符或字符串） Writer 字符流类 2、字节流：InputStream（输入字节流）、OutputStream（输出字节流）、FileInputStream（文件输入流）、FileOutputStream（文件输出流） 3、字符流：Reader（流式字符输入模式的抽象类）、Writer（流式字符输出的抽象类）、FileReader（读取文件内容的 Reader 类）、FileWriter（写文件的 Writer 类） 4、管道流：用于连接两个线程间的通信，分为字节流（PipedInputStream、PipeOutputStream）和字符流（PipeReader、PipeWriter）两种 5、ByteArrayInputStream 和 ByteArrayOutputStream，可以实现类似于内存虚拟文件的功能 6、System.in（InputStream 类型，对应键盘）和 System.out（PrintStream 类型，对应显示器） 7、打印流 PrintStream、PrintWriter 8、合并流 9、字节流和字符流的转换 10、IO 包中的类层次关系图 字符编码 java 中的字符使用的都是 Unicode 编码 对象序列化 是指将对象转换成二进制数据流的一种实现手段 11、网络编程的基本概念 TCP：属于可靠的连接，使用三方握手的方法完成链接的确认 UDP：属于不可靠的连接 对于网络开发有两种架构： C&#x2F;S：客户端&#x2F;服务端，开发两套代码 B&#x2F;S：浏览器&#x2F;服务器，一套代码，类似于论坛","categories":[{"name":"Others","slug":"Others","permalink":"https://jiangjingscom.github.io/categories/Others/"}],"tags":[{"name":"Program","slug":"Program","permalink":"https://jiangjingscom.github.io/tags/Program/"}]},{"title":"使用JavaScript的一些小规则","date":"2017-11-03T13:09:22.000Z","path":"2017/11/03/20171103/","text":"使用 JavaScript 的一些小规则 规则 1：表示区块起首的大括号，不要另起一行。return { key : value; }; 规则 2：调用函数的时候，函数名与左圆括号之间没有空格。 规则 3：函数名与参数序列之间，没有空格。 规则 4：所有其他语法元素与左括号之间，都有一个空格。 规则 5：不要省略句末的分号。 规则 6：不要使用 with 语句。with 可以减少代码的书写，但是会造成混淆。 with (o) { foo &#x3D; bar; }上面的代码，可以有四种运行结果： o.foo &#x3D; bar; o.foo &#x3D; o.bar; foo &#x3D; bar; foo &#x3D; o.bar;这四种结果都可能发生，取决于不同的变量是否有定义。 规则 7：不要使用”相等”（&#x3D;&#x3D;）运算符，只使用”严格相等”（&#x3D;&#x3D;&#x3D;）运算符。因为”相等”运算符会自动转换变量类型，造成很多意想不到的情况： 0 &#x3D;&#x3D; ‘’&#x2F;&#x2F; true 1 &#x3D;&#x3D; true &#x2F;&#x2F; true 2 &#x3D;&#x3D; true &#x2F;&#x2F; false 0 &#x3D;&#x3D; ‘0’ &#x2F;&#x2F; true false &#x3D;&#x3D; ‘false’ &#x2F;&#x2F; false false &#x3D;&#x3D; ‘0’ &#x2F;&#x2F; true “ \\t\\r\\n “ &#x3D;&#x3D; 0 &#x2F;&#x2F; true 规则 8：不要将不同目的的语句，合并成一行。 规则 9：所有变量声明都放在函数的头部。 规则 10：所有函数都在使用之前定义。 规则 11：避免使用全局变量；如果不得不使用，用大写字母表示变量名，比如 UPPER_CASE。Javascript 最大的语法缺点，可能就是全局变量对于任何一个代码块，都是可读可写。这对代码的模块化和重复使用，非常不利。 规则 12：不要使用 new 命令，改用 Object.create()命令。Javascript 使用 new 命令，从建构函数生成一个新对象。 var o &#x3D; new myObject();这种做法的问题是，一旦你忘了加上 new，myObject()内部的 this 关键字就会指向全局对象，导致所有绑定在 this 上面的变量，都变成全部变量。 规则 13：建构函数的函数名，采用首字母大写（InitialCap）；其他函数名，一律首字母小写。 规则 14：不要使用自增（++）和自减（–）运算符，用+&#x3D;和-&#x3D;代替。 规则 15：总是使用大括号表示区块。","categories":[{"name":"Font-end","slug":"Font-end","permalink":"https://jiangjingscom.github.io/categories/Font-end/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jiangjingscom.github.io/tags/JavaScript/"}]},{"title":"《JavaScript+DOM 高级程序设计》笔记","date":"2017-10-11T14:12:22.000Z","path":"2017/10/11/20171011/","text":"《JavaScript+DOM 高级程序设计》 遵循最佳实践： 不唐突和渐进增强 –与标准兼容、容易维护、具有可访问性、具有可用性 12345&lt;a href=&quot;http://advanceddomscripting.com&quot; onclick=&quot;popup(this.href);return false;&quot; &gt;Advancedomsripting&lt;/a&gt; 注：发生 onclick 事件，返回 false 阻止默认事件（忽略执行链中其余的事件，包括默认动作，不再打开 href 属性中的链接） 避免直接在 href 属性中使用编码的 javascript:，而是将适当的函数赋给事件属性。即不要用 href&#x3D;”javascript:popup(http://advancedomscripting.com)“方式，会默认打开页面 注意行为与结构分离，平稳退化 不要版本检测 –能力检测，执行代码前检测某个脚本或者方法是否存在 不要使用 JavaScript 生成内容 构建 ADS 库 示例： 123456789(function () &#123; if (!window.ADS) &#123; window[&quot;ADS&quot;] = &#123;&#125;; &#125; function isCompatible(other) &#123;&#125; window[&quot;ADS&quot;][&quot;isCompatible&quot;] = isCompatible; function $() &#123;&#125; window[&quot;ADS&quot;][&quot;$&quot;] = $;&#125;); 具体的 function isCompatible(other){};方法可以从网上找到，例如： ADS.isCompatible()方法用于确定当前浏览器是否与整个库兼容，可以这样写： 12345678910111213function isCompatible(other) &#123; if ( other === false || !Array.prototype.push || !Object.hasOwnProperty || !document.createElement || !document.getElementsByTagName ) &#123; return false; &#125; return true;&#125;window[&quot;ADS&quot;][&quot;isCompatible&quot;] = isCompatible; JS 语法中的常见陷阱： 1、区分大小写； 2、单、双引号； 3、换行（字符串中随意换行会解析为分号，需要反斜杠来转义换行符）； 4、可选的分号和花括号； 5、相同名称的函数只存在一个实例，JS 不支持重载 6、匿名函数 7、作用域（某一属性或方法具有访问权限的代码空间）解析和闭包（指内部函数即使在外部函数执行完成并终止以后，仍然可以访问外部函数的属性） 作用链（用来描述一种路径的术语，沿着该路径可以确定变量的值（或者当函数被调用时要使用的方法）） 示例： 123456789101112function initAnchors() &#123; for (var i = 1; i &lt;= 3; i++) &#123; var anchor = document.getElementById(&quot;anchor&quot; + i); // ADS.addEvent(anchor,&#x27;click&#x27;,function()&#123; //alert(&quot;My is is anchor&quot;+i); // &#125;); anchor.onclick = function () &#123; alert(&quot;My is is anchor&quot; + i); &#125;; &#125;&#125;initAnchors(); 8、迭代对象 9、函数的调用和引用 一是调用函数将它的返回结果赋给一个值: var foo&#x3D;exampleFunction(); 二是将函数的引用赋给一个值： 1var foo = exampleFunction; //在需要将函数作为数据赋值或者传给其他方法时使用 创建可重用对象 1、继承 与传统的基于类的面向对对象语言不同，JavaScript 中没有从一个类扩展出另一个类的底层类结构，它是通过从一个对象原型向另一哥们对象原型复制方法实现的 实例：从 person 对象中继承方法 employee.getName &#x3D; person.getName; 2、理解对象的成员 document 的 body 属性和 getElementById 方法都可以看做 document 对象的成员，getElementById 方法可以接受参数并操作对象的内部状态 3、window 中的对象 4、理解作用域和闭包 5、创建自己的对象 实例：每一个核心对象 如 Object、Function、Array、String 都含有构造函数 var myObject &#x3D; new object(); 或者： var myObject &#x3D; {}; 6、一变多：创建构造函数 Function 对象的特殊之处在于，它的实例也能作为构造器方法，因而可以用来创建函数的新实例 7、添加静态方法 实例： var myObject &#x3D; new Object(); myObject.alertName&#x3D; function(){}; 通过在对象实例上使用点号操作符，可以将属性和方法作为静态成员添加到对象实例中。但这里的静态成员只存在对象的一个具体实例而不存在于构造函数中。 实例： var myConstrustor &#x3D; function(){}; myConstrustor.alertName &#x3D; function(){}; 这里，myConstrustor 既是一个实例也是一个构造函数，但是 name 和 alerName 成员同样不会应用到 myConstrustor 的任何新的实例中 8、向原型中添加公有方法 如果想要实例化新对象时包含公有方法，则需要修改构造函数的原型（ prototype）。这里的原型不是指 Prototype 这个 JavaScript 框架（http:prototypejs.org），而是指对象的 prototype 属性。当修改一个对象的原型时，任何继承该对象和该对象已经存在的所有实例都会立即继承同样的变化 实例： function myConstructor(message){}; myConstructor.prototype.clearMessage &#x3D; function(0{}; 在这林，向 prototype 中添加成员将会把新的方法添加到 myConstructor 的底层定义中，而不是添加到实例自身 但是：我们不能直接使用 myConstructor.clearMessage 来调用此方法，因为 myConstructor 是 Function 对象的一个实例，而不是 myConstructor 对象的实例。 通过私有和特权成员来控制访问。 私有成员：在对象中使用 var 和 function 等来定义成员。 特权成员：在对象中 使用 this 来定义成员，此时定义的方法位于构造函数的作用域内，因而可以通过作用域链访问私有的成员 注：区分公有、私有、特权、静态 成员 私有和特权在函数的内部，可以带到函数的每一个实例中；公有的原型成员适用于通过 new 关键字实例化的该对象的每一个实例中；静态成员只适用于对象的一个特殊实例。 9、对象字面量 {键：值，键：值}语法中的“键&#x2F;值”对会成为对象的静态成员，如果给某个键指定的值是一个匿名函数，那么该函数会变成对象的静态方法。 对象字面量语法会自动创建 object 对象的实例，因此不能使用 new 关键字来进行实例化 10、this 是什么 JavaScript 会在事件侦听器被调用的环境中将 this 作为一个关键字来解析，因此 this 会被解析为将函数作为其方法的对象（例如将事件作为方法的 HTML 元素） this 简单老函数中引用的是全局 window 对象。 对于 call()而言，每个参数都应该在对象之后，即：call(object ,argument1,angument2) 对于 applay()，则应该将方法的参数作为一个数组放在第 2 个参数的位置上传递。 这是它们之间唯一的区别 11、try()和 catch()和异常处理 12、自己的调试日志 创建一个简易用的调试日志对象，一遍代替 alert()进行调试的技术 DOM2 核心和 DOM HTML 响应用户操作和事件 事件可以分为几种类型：对象事件、鼠标事件、键盘事件、表单事件、W3C 事件以及针对浏览器的事件 对象事件既适用于 JavaScript 对象（例如 window 对象），也适用于 DOM 对象（HTMLImageElement 对象）： 1、load 事件和 unload 事件 在应用 window 对象时。load 和 unload 事件是针对浏览器的，而且是在 DOM2 事件规范的领域之外执行的。 2、abort 事件和 error 事件 error 事件侦听载入错误 abort 事件作用很小。在图像完全载入之前，因浏览器停止载入页面而导致载入失败时，调用。例如单机浏览器停止按钮时 3、resize 事件 当调整浏览器窗口的大小并导致文档视图发生改变时发生 resize 事件 4、scroll 事件 适用于具有 overflow：auto 样式的元素，并且会在元素滚动期间多次调用。可能引发的操作有拖动滚动条、滚动鼠标滚轮、按下键盘中的方向键等 鼠标移动事件： mousemove 事件、 mouseover 事件、 mouseout 事件 鼠标单击事件：当单击并释放鼠标，保持鼠标不动，会一次执行以下事件 mousedown 事件、 mouseup 事件、 只有在鼠标不动才发生，click 事件 如果快速按两次，则会在 click 事件后发生 dbclick 事件 若点击时移动则会产生不同效果，注意 mouseup 和 mousedown 并不一定成对出现 键盘事件：键盘膜事件只适用于 document 事件，会一次调用 keydown 事件 keyup 事件 keypress 事件，紧随 keyup 事件之后，表示有一个键被按过了 表单事件： 1、表单的 submit 事件和 reset 事件 2、blur 事件和 focus 事件适用于&lt;label&gt;、&lt;input&gt;、&lt;select&gt;、&lt;textarea&gt;和&lt;button&gt;等表单元素 focus 事件会在用户单击一个元素或者按 Tab 键切换到一个元素时调用而单击元素之外的其他地方或者按 Tab 键离开该元素，则会在原先调用 focus 事件的元素上调用 blur 事件 3、change 事件适用于&lt;input&gt;、&lt;select&gt;、&lt;textarea&gt;表达元素，该事件会在 focus 事件发生后，当用户在 focus 和 blur 事件之间修改元素的值时被调用。 针对 W3C DOM 事件： 在DOM2事件规范中，有三个用户界面事件： DOMFocusIn和DOMFocusOut事件，原理上与focus和blur事件相同。只不过它们适用于任何DOM元素 DOMActivate事件，会在DOM元素被鼠标指针单击或者按下键盘上的某个键而激活时被调用 此外，在修改DOM文档结构时，还会调用7种变化事件：DOMSubtreeModified、DOMNodeInserted、DOMNodeRemoved、DOMNodeRemovedFromDocument、NodeInsertedIntoDocument、DOMAttrModified、DOMCharacterDataModified 控制事件流和注册事件侦听器 事件流 1、事件的顺序 2、两个阶段和三个模型 3、阻止冒泡 4、取消默认动作在事件侦听器中访问事件对象在 W3C 的模型中，事件侦听器会取得一个表示事件自身的参数","categories":[{"name":"Font-end","slug":"Font-end","permalink":"https://jiangjingscom.github.io/categories/Font-end/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jiangjingscom.github.io/tags/JavaScript/"}]},{"title":"《JavaScript+DOM 编程艺术》笔记","date":"2017-08-12T13:32:22.000Z","path":"2017/08/12/20170812/","text":"《JavaScript+DOM 编程艺术》笔记 用 JavaScript 写的代码必须放在 html 中才能执行： 1、将代码放在&lt;head&gt;标签部分的&lt;script&gt;标签间 2、另写.js 文件，再在&lt;head&gt;标签部分的&lt;script&gt;标签间 使用 src 引用 12345678&lt;html&gt; &lt;head&gt; &lt;script src=&quot;app.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; javaScrip 弱类型语言，数据类型可不声明，可随便改变某个变量的数据类型；解释性语言，需要解释器，代码错误仅在解释器执行时才能发现。 alert(mood) 弹出一个警告窗口，显示 mood 的值。 区分字母大小，变量可不声明就使用，一般先声明，可同时声明多个变量。 变量名称允许包括字母、数字、美元符号和下划线字符。 离散值：字符串、数值、布尔值 字符串：放在单引号或双引号内部，若引号内部包括双引号，应用单引号包括。转义字符：\\\\ 数值：可以是整数或小数，负数直接在数字前加上- 声明数组 Array，即可不用指明长度，其内部可以包含 string 或 int，也可以包含另一个数组 关联数组：数组小标为字符串，数组数组可作为关联数组的特例 拼接：+ 可用于拼接字符串、数值 DOM：document（文档）、object（对象）、model（模型）。 当创建一个网页并加载到 Web 浏览器中时，DOM 就在幕后产生，它将根据我编写的网页文档创建一个文档对象。 JS 语言中的对象三种类型： 用户自定义对象：由程序自行创建的对象； 内建对象：内建在 JavaScrip 语言里的对象，如 Array、Math 和 Data 等； 宿主对象：由浏览器提供的对象； 最基础的对象：Window 对象，对应浏览器窗口本身，这个对象的属性和方法通常被称为 BOM（浏览器对象模型）。BOM 提供了 window.open 和 window.blur 等方法； 浏览器的内容，目标载体：document 对象。 getElementById()方法：返回有着给定 id 的某个对象，例如： document.getElementById(“purchases”) 得到某个 id 为 purchases 的对象 getElementsByTagName()方法：返回一个对象数组，每个对象分别对应着文档给定标签的元素。 例如：document.getElementBytagName(“li”) 返回一个对象数组，每个对象分贝对应着 document 对象中的一个列表项（li）元素 利用通配符*返回所有元素对象。例如：document.getElementBytagName(“*“) getAttribute()方法：参数为查询属性的名字，得到属性值。不能通过 document 对象调用它，只能通过元素节点对象调用它。 object.getAttribute(attribute) setAttribute()方法：object.setAttribute(attribute,value)修改某个元素的某个属性值 例如: 123var shopping = document.getElementById(&quot;purchases&quot;);shopping.setAttribute(&quot;title&quot;, &quot;a list of goods&quot;); childNodes 属性：返回一个数组（包含着所有类型的节点，元素节点、文本节点、所有属性节点等），element.childNodes 返回此元素的所有子元素； （firstChild、lastChild） nodeType 属性：用于得到文本节点的类型 元素节点的 nodeType 属性值是 1 属性节点的 nodeType 属性值是 2 文本节点的 nodeType 属性值是 3 nodeValue 属性：用于改变文本节点的值 例如：alert(description.childNodes[0].nodeValue);得到 description 第一个子节点的值 创建新的窗口： window.open(url,name,features) 三个参数都是可选，第一个打开文档的 url 地址，无此参数则打开一个空白的窗口 第二个是新窗口的名字，可以通过这个名字与新窗口进行通信 第三个是以逗号分隔的字符串，内容是新窗口的各种属性，这些属性包括新窗口的尺寸以及新窗口被激活或禁用的各种浏览功能（工具条、菜单条、初始显示位置） “javascript:”伪协议 pupUp()函数可以通过为协议来调用 “真协议”是指那些用来在因特网上的两台计算机之间传输各种数据包的标准化通信机制，如 http://、ftp://等，伪协议则是人们对非标准化通信机制的统称 “JavaScript：”伪协议让我们可以通过一个链接来调用 javascript 函数。 DOM 中的节点是分好几种类型,常见的有1.文档节点 （document，唯一）2.元素节点 （那些个标签 div,p 之类）3.属性节点（class,src 这种）4.文本节点（插入在 p，div 内的文本）其它。。 其中 element.nodeValue，是节点的值，其中属性节点和文本节点是有值的，而元素节点没有值。 innerHTML 以字符串形式返回该节点的所有子节点及其值","categories":[{"name":"Font-end","slug":"Font-end","permalink":"https://jiangjingscom.github.io/categories/Font-end/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jiangjingscom.github.io/tags/JavaScript/"}]},{"title":"JavaScript闭包","date":"2017-08-12T13:32:22.000Z","path":"2017/08/12/20170922/","text":"JavaScript 闭包理解 闭包：类是有行为的数据，闭包是有数据的行为。官方解释;「闭包」，是指拥有多个变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。 一、变量的作用域 要理解闭包，首先必须理解 Javascript 特殊的变量作用域。变量的作用域无非就是两种：全局变量和局部变量。Javascript 语言的特殊之处，就在于函数内部可以直接读取全局变量。 12345var n = 999;function f1() &#123; alert(n);&#125;f1(); // 999 另一方面，在函数外部自然无法读取函数内的局部变量。 1234function f1() &#123; var n = 999;&#125;alert(n); // error 这里有一个地方需要注意，函数内部声明变量的时候，一定要使用 var 命令。如果不用的话，你实际上声明了一个全局变量！ 12345function f1() &#123; n = 999;&#125;f1();alert(n); // 999 二、如何从外部读取局部变量？出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。 123456function f1() &#123; var n = 999; function f2() &#123; alert(n); // 999 &#125;&#125; 在上面的代码中，函数 f2 就被包括在函数 f1 内部，这时 f1 内部的所有局部变量，对 f2 都是可见的。但是反过来就不行，f2 内部的局部变量，对 f1 就是不可见的。这就是 Javascript 语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。既然 f2 可以读取 f1 中的局部变量，那么只要把 f2 作为返回值，我们不就可以在 f1 外部读取它的内部变量了吗！ 123456789function f1() &#123; var n = 999; function f2() &#123; alert(n); &#125; return f2;&#125;var result = f1();result(); // 999 三、闭包的概念 上一节代码中的 f2 函数，就是闭包。各种专业文献上的”闭包”（closure）定义非常抽象，很难看懂。我的理解是，闭包就是能够读取其他函数内部变量的函数。由于在 Javascript 语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 四、闭包的用途1、setTimeout&#x2F;setInterval2、回调函数（callback）3、事件句柄（event handle）闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。怎么来理解这句话呢？请看下面的代码。 1234567891011121314function f1() &#123; var n = 999; nAdd = function () &#123; n += 1; &#125;; function f2() &#123; alert(n); &#125; return f2;&#125;var result = f1();result(); // 999nAdd();result(); // 1000 在这段代码中，result 实际上就是闭包 f2 函数。它一共运行了两次，第一次的值是 999，第二次的值是 1000。这证明了，函数 f1 中的局部变量 n 一直保存在内存中，并没有在 f1 调用后被自动清除。为什么会这样呢？原因就在于 f1 是 f2 的父函数，而 f2 被赋给了一个全局变量，这导致 f2 始终在内存中，而 f2 的存在依赖于 f1，因此 f1 也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。这段代码中另一个值得注意的地方，就是”nAdd&#x3D;function(){n+&#x3D;1}”这一行，首先在 nAdd 前面没有使用 var 关键字，因此 nAdd 是一个全局变量，而不是局部变量。其次，nAdd 的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以 nAdd 相当于是一个 setter，可以在函数外部对函数内部的局部变量进行操作。 五、使用闭包的注意点 1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在 IE 中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 六、思考题 如果你能理解下面两段代码的运行结果，应该就算理解闭包的运行机制了。代码片段一。 12345678910var name = &quot;The Window&quot;;var object = &#123; name: &quot;My Object&quot;, getNameFunc: function () &#123; return function () &#123; return this.name; &#125;; &#125;,&#125;;alert(object.getNameFunc()()); //打印：The Window 代码片段二。 123456789101112var name = &quot;The Window&quot;;var object = &#123; name: &quot;My Object&quot;, getNameFunc: function () &#123; var that = this; return function () &#123; return that.name; &#125;; &#125;,&#125;;alert(object.getNameFunc()()); //打印 My Object","categories":[{"name":"Font-end","slug":"Font-end","permalink":"https://jiangjingscom.github.io/categories/Font-end/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jiangjingscom.github.io/tags/JavaScript/"}]},{"title":"关于JSON.stringify","date":"2017-07-13T15:22:01.000Z","path":"2017/07/13/20170713/","text":"关于 JSON.stringify 操作特性：1、某些值操作时表现不一致 对于 undefined、任意的函数以及 symbol 作为对象属性值时 JSON.stringify() 将跳过（忽略）对它们进行序列化 undefined、任意的函数以及 symbol 作为数组元素值时，JSON.stringify() 会将它们序列化为 null undefined、任意的函数以及 symbol 被 JSON.stringify() 作为单独的值进行序列化时，都会返回 undefined 2、由于序列化时会忽略一些特殊的值，非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中。 3、转换值如果有 toJSON() 函数，该函数返回什么值，序列化结果就是什么值，并且忽略其他属性的值 4、JSON.stringify() 将会正常序列化 Date 的值。Date 对象自己部署了 toJSON() 方法（同 Date.toISOString()），因此 Date 对象会被当做字符串处理。 5、NaN 和 Infinity 格式的数值及 null 都会被当做 null。 6、布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值。 7、 其他类型的对象，包括 Map&#x2F;Set&#x2F;WeakMap&#x2F;WeakSet，仅会序列化可枚举的属性。 8、 对包含循环引用的对象（对象之间相互引用，形成无限循环）执行 JSON.parse(JSON.stringify())此方法，会抛出错误。 9、所有以 symbol 为属性键的属性都会被完全忽略掉，即便 replacer 参数中强制指定包含了它们。 JSON.stringify() 第二个参数和第三个参数： 第二个参数 replacer：1、作为函数时，它有两个参数，键（key）和值（value），函数类似就是数组方法 map、filter 等方法的回调函数，对每一个属性值都会执行一次该函数（期间我们还简单实现过一个 map 函数）2、如果 replacer 是一个数组，数组的值代表将被序列化成 JSON 字符串的属性名。 第三个参数 space：","categories":[{"name":"Font-end","slug":"Font-end","permalink":"https://jiangjingscom.github.io/categories/Font-end/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jiangjingscom.github.io/tags/JavaScript/"}]},{"title":"《jQuery 基础教程》笔记","date":"2017-06-11T12:22:01.000Z","path":"2017/06/11/20170611/","text":"《jQuery 基础教程》笔记 第一张：jQuery 入门 jQuery 能做什么: 取得文档的元素 $(‘div.content’).find(‘p’); 修改页面外观 $(‘ul &gt; li:first’).addClass(‘active’); 改变文档的内容 $(‘#container’).append(‘more‘); 响应用户交互操作 $(‘button.show-details’).click(function(){ $(‘div.details’).show(); }); 为页面增加动态效果 内置淡入等效果和工具包 $(‘div.details’).slideDown(); 无需刷新页面从服务器获取信息 ajax $(‘div.details’).load(‘more.html #content’); 简化常见的 javaScript 任务(例如迭代和数组操作) $.each(obj,function(key,value){ total +&#x3D; value; }); jQuery 采用的策略; 利用 CSS 的优势 支持扩展 抽象浏览器不一致特性 总是面向集合 将多重操作集于一行 第二章：选择元素 元素关系： 是其他所有元素的祖先元素，换句话说，其他所有元素都是的后代 元素。和元素是的子元素（但并不是它唯一的子元素）。因此除了作为 和的祖先元素之外，也是它们的父元素。 而元素则是的子元 素（也是后代元素），是和的后代元素，是其他元素的同辈元素。 jQuery 的基本操作之一就是选择文档中的一部分，一般通过$( )函数完成，通常该函数需要一个字符串参数，参数中可以包含任何 CSS 选择符表达式。该函数返回 jQuery 对象实例 注：在 jQuery 中，$只是标识符jQuery的别名，而$( )在 JavaScript 的库中很常见，当引用多个这样的库时，为避免冲突，应用 jQuery 来代替 4 3 中基本选择符： 标签名、ID 和类 在将方法连缀到$( )工厂函数后面时，包装在 jQuery 对象中的元素会被自动、隐式地循环遍历，这样避免了 for 循环的显示迭代 原生页面加载事件：window.onload 事件，.onload 属性一次只能保存对一个函数的引用，所以不能在现有的行为基础上再增加新行为。通过$(document).ready()机制能够很好地解决这个问题。每次调用这个方法都会向内部的行为队列中添加一个新函数，当页面加载完成后，所有函数都会被执行。而且，这些函数会按照注册它们的顺序依次执行。 CSS 选择符： 12345$(document).ready(function() &#123; $(&#x27;#selected-plays &gt; li&#x27;).addClass(&#x27;horizontal&#x27;);&#125;); 表示：查找 ID 为 selected-plays 的元素(#selected-plays )的子元素( &gt; )中的所有的列表项( li ) $(‘#selected-plays li:not(.horizontal)’).addClass(‘sub-level’); 表示：ID 为 selected-plays 的元素的后代元素，没有 horizontal 类，添加 sub-level 类 属性选择符：属性选择符可以组合使用 $(‘img[alt]‘) 选择带有 alt 属性的所有 img 元素 $(document).ready(function(){ $(‘a[href^&#x3D;”mailto:”]‘).addClass(‘mailto’); }); 表示：寻找带有 href 属性且以 mailto 开头的锚元素（a） $(‘a[href$&#x3D;”.pdf”]‘).addClass(‘pdflink’); 表示：选择所有 href 属性以.pdf 结尾的链接 $(‘a[href^&#x3D;”http”][href*&#x3D;”henry”]‘).adClass(‘henrylink’); 表示：为 href 属性以 http 开头且任意位置包含 henry 的所有链接添加一个 henrylink 类 自定义选择符：（注：只要可能，jQuery 就会使用浏览器原生的 DOM 选择符引擎去查找元素。但在 使用自定义选择符的时候，就无法使用速度最快的原生方法了。因此，建议读者 在能够使用原生方法的情况下，就不要频繁地使用自定义选择符，以确保性能。） 自定义选择符 的语法与 CSS 中的伪类选择符语法相同，即选择符以冒号（:）开头。例如，我们想要从带有 horizontal 类的集合中选择第 2 项，那么应该使用下面的代码： $(‘div.horizontal:eq(1)’) 基于上下文内容选择元素、基于表单的选择符 注意，因为 JavaScript 数组采用从 0 开始的编号方式，所以 eq(1)取得的是集合中的第 2 个元素。 而 CSS 则是从 1 开始的，因此 CSS 选择符$(‘div:nth-child(1)’)取得的是作为其父元素第 1 个 子元素的所有 div 元素。如果记不清哪个从 0 开始，哪个从 1 开始，可以参考 jQuery API 文档： http://api.jquery.com/category/selectors/。 第三章：事件 事件： FF 运载标准事件模型（即同时支持捕获和冒泡），要把事件处理注册到捕获阶段，必须在标准的事件注册方法 addEventListener()中将最后一个参数设置为 true。 而 IE 的事件注册方法 attachEvent()只能将事件处理程序注册到冒泡阶段。为了提供跨浏览器兼容性，jQuery 始终会在模型的冒泡阶段注册事件处理程序（即为了和 IE 兼容），因此，我们总是可以假定最具体的元素会首先获得响应事件的机会。 由此产生的副作用： 假设在我们的例子中，为添加了一个 mouseout 事件处理程序。当用户的鼠标指针退出这个时，会按照预期运行 mouseout 处理程序。因为这个过程发生在顶层元素上，所以其他元素不会取得这个事件。但是，当指针从&lt;a&gt;元素上离开时，&lt;a&gt;元素也会取得一个 mouseout 事件。然后，这个事件会向上冒泡到和，从而触发上述的事件处理程序。这种冒泡序列很可能不是我们所希望的。 方法一：事件处理程序中的变量 event 保存着事件对象。而 event.target 属性保存着发生事件的目标元素。 12345678910111213$(document).ready(function() &#123; $(&#x27;#switcher&#x27;).click(function(event) &#123; if (event.target == this) &#123; $(&#x27;#switcher button&#x27;).toggleClass(&#x27;hidden&#x27;); &#125; &#125;);&#125;); 此时的代码确保了被单击的元素是，而不是其他后代元素。现在，单击按钮不会再折叠样式转换器，而单击转换器背景区则会触发折叠操作。但是，单击标签&lt;h3&gt;同样什么也不会发生，因为它也是一个后代元素。实际上，我们可以不把检查代码放在 这里，而是通过修改按钮的行为来达到目标。 方法二：事件对象还提供了一个.stopPropagation()方法，该方法可以完全阻止事件冒泡。与.target 类似，这个方法也是一种基本的 DOM 特性，但在 IE8 及更早版本中则无法安全地使用。不过，只要我们通过 jQuery 来注册所有的事件处理程序，就可以放心地使用这个方法。 阻止默认事件操作： 在事件对象上调用.stopPropagation()方法也不能禁止这种默认操作，因为默认操作不是在正常的事件传播流中发生的。在这种情况下，.preventDefault()方法则可以在触发默认操作之前终止事件。 事件委托： 事件冒泡并不总是带来问题，也可以利用它为我们带来好处。事件委托就是利用冒泡的一项高级技术。通过事件委托，可以借助一个元素上的事件处理程序完成很多工作。 例如，有一个显示信息的大型表格，每一行都有一项需要注册单击处理程序。虽然不难通过隐式迭代来指定所有单击处理程序，但性能可能会很成问题，因为循环是由 jQuery 在内部完成的，而且要维护所有处理程序也需要占用很多内存。为解决这个问题，可以只在 DOM 中的一个祖先元素上指定一个单击处理程序。由于事件会冒泡，未遭拦截的单击事件最终会到达这个祖先元素，而我们可以在此时再作出相应处理。 12345678910111213141516171819202122232425$(document).ready(function() &#123; $(&#x27;#switcher-default&#x27;).addClass(&#x27;selected&#x27;); $(&#x27;#switcher&#x27;).click(function(event) &#123; if ($(event.target).is(&#x27;button&#x27;)) &#123; var bodyClass = event.target.id.split(&#x27;-&#x27;)[1]; $(&#x27;body&#x27;).removeClass().addClass(bodyClass); $(&#x27;#switcher button&#x27;).removeClass(&#x27;selected&#x27;); $(event.target).addClass(&#x27;selected&#x27;); &#125; else &#123; $(&#x27;#switcher button&#x27;).toggleClass(&#x27;hidden&#x27;); &#125; &#125;);&#125;); 注：is()与.hasClass()：要测试元素是否包含某个类，也可以使用另一个简写方法.hasClass()。不过，.is()方法则更灵活一些，它可以测试任何选择符表达式。 使用内置的事件委托功能： 由于事件委托可以解决很多问题，所以 jQuery 专门提供了一组方法来实现事件委托。前面讨论过的.on()方法可以接受相应参数实现事件委托 1234567891011$(&#x27;#switcher&#x27;).on(&#x27;click&#x27;, &#x27;button&#x27;, function() &#123; var bodyClass = event.target.id.split(&#x27;-&#x27;)[1]; $(&#x27;body&#x27;).removeClass().addClass(bodyClass); $(&#x27;#switcher button&#x27;).removeClass(&#x27;selected&#x27;); $(this).addClass(&#x27;selected&#x27;);&#125;); 如果给.on()方法传入的第二个参数是一个选择符表达式，jQuery 会把 click 事件处理程序 绑定到#switcher 对象，同时比较 event.target 和选择符表达式（这里的’button’）。如果匹 配，jQuery 会把 this 关键字映射到匹配的元素，否则不会执行事件处理程序。 第四章：样式与动画 普通动画，jQuery 预置动画：淡入淡出、滑上滑下………. 创建自定义动画： .animate()方法有两种形式，第一种形式接收以下 4 个参数。  一个包含样式属性及值的对象：与本章前面讨论的.css()方法中的参数类似。  可选的时长参数：既可以是预置的字符串，也可以是毫秒数值。  可选的缓动（easing）类型：现在我们先不介绍，这是第 11 章中将要讨论的一个高级选项。  可选的回调函数：将在本章后面讨论。 把这 4 个参数放到一起，结果如下所示： 12345678910.animate(&#123; property1: &#x27;value1&#x27;, property2: &#x27;value2&#x27;&#125;,duration, easing, function() &#123; alert(&#x27;The animation is finished.&#x27;);&#125;); 第二种形式接受两个参数，一个属性对象和一个选项对象： .animate({properties}, {options}) 实际上，这里的第二个参数是把第一种形式的第 2 ～ 4 个参数封装在了另一个对象中，同时又 添加了两个选项。考虑到可读性并调整了换行之后，调用第二种形式的方法的代码如下： 12345678910111213141516171819202122232425262728293031.animate(&#123; property1: &#x27;value1&#x27;, property2: &#x27;value2&#x27;&#125;, &#123; duration: &#x27;value&#x27;, easing: &#x27;value&#x27;, specialEasing: &#123; property1: &#x27;easing1&#x27;, property2: &#x27;easing2&#x27; &#125;, complete: function() &#123; alert(&#x27;The animation is finished.&#x27;); &#125;, queue: true, step: callback&#125;); 第五章：操作 DOM 操作 DOM： 1、利用 DOM 提供的接口修改文档； 2、在网页中根据需要创建元素和文本 3、移动或删除元素 4、通过添加、删除和修改它们的属性来实现文档内容的变换 操作属性: .addClass()和.removeClass()方法可以改变页面上元素的外观，但 jQuery 实际上是在操作 DOM 中的 className 属性。 非类属性：操作其他一些属性，比如 id、rel 和 title 属性。jQuery 为此也提供了.attr()和.revoveAttr()方法。此外，通过 jQuery 还可以一次修改多个属性，同我们在第 4 章中使用.css()方法修改多个 CSS 属性的方式类似。 注：HTML 属性与 DOM 属性有一点区别。HTML 属性是指页面标记中放在引号中的值，而 DOM 属性则是指通过 JavaScript 能够存取的值。 表单控件的值： HTML 属性和 DOM 属性差别最大的地方，在表单控件。例如：文本输入框 value 属性在 DOM 中的属性叫 defaultValue，DOM 中就没有 value 属性。由于存在这些差异，在取得和设置表单控件的值时，最好不要使用.atrr()方法，建议使用.val(); 1234567891011// Get the value of the input field with the id &quot;my-input&quot;.var inputValue = $(&quot;#my-input&quot;).val();// Get the value of the select field with the id &quot;my-select&quot;.var selectValue = $(&quot;#my-select&quot;).val();// Set the value of the select field with the id &quot;my-single-select&quot; to &quot;value3&quot;.$(&quot;#my-single-select&quot;).val(&quot;value3&quot;);// Set the value of the select field with the id &quot;my-multi-select&quot; to [&quot;value1&quot;, &quot;value2&quot;].$(&quot;#my-multi-select&quot;).val([&quot;value1&quot;, &quot;value2&quot;]); 我们一直在使用$()函数来访问文档中的元素。这个函数就像一个工厂， 它能够生成一个 jQuery 对象，指向 CSS 选择符所描述的一组元素。 然而，除了选择元素之外，$()函数的圆括号内还有另外一个玄机——这个强大的特性使得 $()函数不仅能够改变页面的视觉外观，更能改变页面中实际的内容。只要在这对圆括号中放入 一组 HTML 元素，就能轻而易举地改变整个 DOM 结构 第六章：通过 Ajax 发送数据 Ajax 1、不断刷新页面而从服务器加载数据 2、通过 JavaScript 在浏览器向服务器发送数据 3、在客户端使用 HTML、XML 和 JSON 等数据 4、向用户反馈 Ajax 请求的状态 $.getJSON() 到目前为止，我们使用的所有 jQuery 方法都需要通过$()函数构建的一个 jQuery 对象进行调 用。通过选择符表达式，我们可以指定一组要操作的 DOM 节点，然后再用这些 jQuery 方法以某种 方式对它们进行操作。然而，$.getJSON()函数却不一样。从逻辑上说，没有该方法适用的 DOM 元素；作为结果的对象只能提供给脚本，而不能插入到页面中。为此，getJSON()是作为全局 jQuery 对象（由 jQuery 库定义的 jQuery 或$对象）的方法定义的，也就是说，它不是个别 jQuery 对象实例（即通过$()函数创建的对象）的方法。 $.getJSON()函数是全局函数，可以接受第 2 个参数，这个参数是当加载完成时调用的函数。如上所述， Ajax 请求都是异步的，回调函数提供了一种等待数据返回的方式，而不是立即执行代码。回调函 数也需要一个参数，该参数中保存着返回的数据。 &#x2F;&#x2F;未完成的代码 1234567891011121314$(document).ready(function () &#123; // Handle click events on anchor elements within the element with the ID &quot;letter-b&quot; $(&quot;#letter-b a&quot;).click(function (event) &#123; // Prevent the default action of the anchor element (e.g., following the link) event.preventDefault(); // Make an AJAX request to retrieve data from the JSON file &quot;b.json&quot; $.getJSON(&quot;b.json&quot;, function (data) &#123; // Once the data is retrieved, perform some action with it (e.g., display it on the page) // In this example, we&#x27;re just logging the data to the console console.log(data); &#125;); &#125;);&#125;); 在此使用了匿名函数表达式作为回调函数，这在 jQuery 代码中很常见，主要是为了保持代码简洁。当然，对函数声明的引用同样也可以作为回调函数。这样，我们就可以在函数中通过 data 变量来遍历 JSON 数据结构了。 下面介绍 jQuery 的另一个实用全局函数$.each() $.each()函数不操作 jQuery 对象，它以数组或对象作为第一个参数，以回调函数 作为第二个参数。此外，还需要将每次循环中数组或对象的当前索引和当前项作为回调函数的两 个参数 1234567891011121314151617181920212223$(document).ready(function () &#123; $(&quot;#letter-b a&quot;).click(function (event) &#123; event.preventDefault(); $.getJSON(&quot;b.json&quot;, function (data) &#123; var html = &quot;&quot;; $.each(data, function (entryIndex, entry) &#123; html += &quot;\\n&quot;; html += &quot;\\n&quot;; html += &quot;### &quot; + entry.term + &quot;\\n&quot;; html += &quot;\\n&quot;; html += &quot;&quot; + entry.part + &quot;\\n&quot;; html += &quot;\\n&quot;; html += entry.definition; html += &quot;\\n&quot;; html += &quot;\\n&quot;; &#125;); $(&quot;#dictionary&quot;).html(html); &#125;); &#125;);&#125;); 这里通过$.each()函数依次遍历每个项，并使用 entry 对象的内容构建起 HTML 代码结构。 构建好 HTML 之后，通过.html()把它插入到中，替换其中原有的所 有内容。 后面内容翻翻即可。","categories":[{"name":"Font-end","slug":"Font-end","permalink":"https://jiangjingscom.github.io/categories/Font-end/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jiangjingscom.github.io/tags/JavaScript/"}]},{"title":"Vue.js使用","date":"2017-05-26T01:41:27.000Z","path":"2017/05/26/20170526/","text":"又有一个多月没写博客了，这篇记录一下最近一个月忙的事情——将使用AngularJS(v1.5.4)框架写的后台换成Vue.js(v2.2.6)啦巨开心！至于我为什么换,大概是因为每次版本迭代不想按原来的方式改写一遍？时间还算充足？浏览器支持很宽松？想体验ES6写法？听说Vue很棒棒哇？想集齐四大法宝(JQuery&#x2F;AngularJS&#x2F;Vue.js&#x2F;React)……主要原因应该是后台就我一个人在做，想怎么做就怎么做吧哈哈&#x3D; &#x3D;Vue框架使用非常方便，一如它所宣称的轻量高效。而且它的官方文档超级清晰，api对于本菜来说也够用。之前用过几个月的Angular,文档到现在还没有全部看完（嗯，可能我比较懒…但它的东西真的多的不要不要的），但是Vue,它的文档我已经刷了好几遍（闲来无事刷文档）&#x3D; &#x3D;对于我这种准备学习一门语言或框架之前往往需要先完完整整过一两遍比较全的书或文档，才能放心开始学习的人来说，简直不要太棒！嗯，少说废话，进入正题。首先搭一个框架，做好准备工作。用vue-cli脚手架工具(npm install vue-cli -g)，初始化项目(vue init webpack-simple admin)很快得到admin项目下的完整目录： 详细的网上有教程，其中build和config里面放的是一些配置文件(主要是webpack的，用于打包),dist中放的是开发好的目录，如果要直接放在服务器中访问，需要简单修改一下config文件中的index.js,static放静态资源，src就是我们的开发目录啦。除了vue-cli帮我们安装的一些npm包，由于项目需要，另外引入一些工具 123456789101112131415&quot;dependencies&quot;: &#123; // 解决http请求 &quot;axios&quot;: &quot;^0.16.1&quot;, // 解决Babel对于一些api(如Promise等)不转码的问题 &quot;babel-polyfill&quot;: &quot;^6.23.0&quot;, // 强大的时间操作工具 &quot;moment&quot;: &quot;^2.18.1&quot;, // 简单的tooltip &quot;v-tooltip&quot;: &quot;^2.0.0-beta.4&quot;, &quot;vue&quot;: &quot;^2.2.6&quot;, // vue 官方路由 &quot;vue-router&quot;: &quot;^2.3.1&quot;, // vue官方状态管理模式 &quot;vuex&quot;: &quot;^2.3.1&quot;&#125;, 其中，vuex和vue-router都有官方文档，十分详细。引入axios是因为vue不像angular，angular提供的$http服务同服务端通信，相比vue-resource,官方推荐强大的axios！用上babel-polyfill工具，因为想使用一些ES6新的api，真想把它们统统都夸一遍 &#x3D; &#x3D;看一下项目目录： component: 一些组件(toast,tree,modal,avatar),由于不想引入大而全的库(很多东西不需要)，模式组件源于自己写写改改。directive: 一些指令(v-focus)filter: 一些过滤器(时间、文件大小，操作记录等等)，另外，可直接在组件内部使用computed,有时候它更好用。libs: 一些工具，引用库router: 配置vue路由service: 所有http请求，按照原来在angular框架时师傅教的，将所有api独立出来，感觉好写好改好查找。store: vue的状态管理，我主要放了个人信息和组织结构树信息，方便管理数据views: 所有路由页(因为在做单页应用，在只用component还是用部分router两种模式比较了一下，发现都差不多，为了用上全家桶，用上router)展开的就不放了，因为文件特别多 &#x3D; &#x3D;一个简单的component样式： 未完，待续…… —-2018-3-1 更新—- 待续？用完三个框架，感觉Vue最方便好用，简单易入门，解决了数据绑定、组件开发、页面路由等痛点，配套Vuex解决数据管理，差不多了，对于我之前写的小项目来说，好用，没毛病… 有机会还会再用，好评。(^o^)&#x2F;~","categories":[{"name":"Font-end","slug":"Font-end","permalink":"https://jiangjingscom.github.io/categories/Font-end/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jiangjingscom.github.io/tags/JavaScript/"}]},{"title":"Keep-Alive 模式","date":"2017-05-12T12:10:37.000Z","path":"2017/05/12/20170502/","text":"今天学习一下 Keep-Alive 模式，做个记录。 HTTP 协议采用“请求-应答”模式 使用非 Keep-Alive 模式时，每次请求&#x2F;响应客户端和服务端都要新建一个连接，完成后立即断开连接（HTTP 协议为无状态的协议）使用 Keep-Alive 模式时，它能避免了建立或重新建立连接。（不关闭 TCP 链接，继续使用。） http1.0 中默认是关闭的，短链接。需要在头部加入“Connection:Keep-Alive”，才能启用 Keep-Alive。Http1.1 中默认启用 Keep-Alive，持续链接。如果加入“Connection:close”，才关闭。 目前大部分浏览器采用 http1.0 协议，也就是默认发起 Keep-Alive 连接请求，所以是否能完成一个完整的 Keep-Alive 链接需要看服务器的设置情况Keep-Alive 不会永久保持链接，有一个保持时间，可以在服务器中设定这个时间 启用 Keep-Alive 要注意：单用户客户端与任何服务器或代理之间的连接数不应该超过 2；一个代理与其他服务器或代码之间应该使用不超过 2*N 的活跃并发链接 启用 Keep-Alive 模式，客户端如何判断请求所得到的响应数据已经接受完成1、使用消息首部字段 Conent-Length （表示实体长度）2、使用消息首部字段 Transfer-Encoding（传输类型，比如 chunk 模式来分块传输） 市场上大部分服务器都支持 HTTP Keep-Alive。 node 的 http 模块中： 12345const http = require(&#x27;http’);var keepAliveAgent = new http.Agent(&#123; keepAlive: true &#125;);options.agent = keepAliveAgent;http.request(options, onResponseCallback); 通过设置 keepAlive:布尔值（默认为 false）,表示让 Agent 池中的 socket 保持活动状态用于未来的请求。","categories":[{"name":"Font-end","slug":"Font-end","permalink":"https://jiangjingscom.github.io/categories/Font-end/"}],"tags":[]},{"title":"一次http请求","date":"2017-04-17T10:13:27.000Z","path":"2017/04/17/20170417/","text":"好久没有写博客了，记录几天前的一个 bug，顺便回顾一些之前学的 HTTP 知识。客户之前要求浏览器支持 360 和 chrome，对版本没有什么要求。想到 360 极速模式使用的 webkit 内核，平常代码运行在又 chrome 上，我感觉可以任性了！但是最近客户改需求需要运行在 IE10 及以上，小伙伴们开始在 IE10 上测试。其中一处 bug：某次 HTTP 请求在 chrome 上返回 200，但在 IE10 上返回 401。在 chrome 中运行，HTTP 请求详细信息截图如下： 在 IE10 下 HTTP 请求响应码返回 401，表示身份信息有问题，请求失败： 查看 request header： 发现设置在 headers 中的的 authorization 字段不见了，在 chrome 上存在 authorization 字段,那么 IE10 上应该存在，为什么找不到？看到桌面绿色的 fiddler，想到它可以抓到很多 HTTP 信息，可能会得到其他有用的信息。运行 fiddler ，找到目标 session： 得到 IE10 下详细的返回信息： 所以，authorization 还是有的，只是 IE10 没有显示出来，而且变成了 Authorization，首字母大写；应该是后端验证出现问题，将 bug 报给后端被解决。 HTTP 基础知识(HTTP basics)一次完整的请求过程： 1.域名解析 2.建立 TCP 连接，三次握手3.Web 浏览器向 Web 服务端发送 HTTP 请求报文 4.浏览器解析 HTML 代码，并请求 HTML 代码中的资源 6.浏览器对页面进行渲染呈献给用户 7.断开 TCP 连接 HTTP 的请求方法(HTTP&#x2F;1.1: Method Definitions)一些 get 请求方式：1. 直接输入某个地址 2. 点击链接 3. 表单默认提交方式 关于 HTTP 响应码(HTTP Status Code )1xx：#临时响应# 代表请求已经被接受，但需要继续处理。 100 Continue — 服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。 101 Switching Protocols — 服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。 102 Processing — 由 WebDAV(RFC 2518)扩展的状态码，代表处理将被继续执行。2xx：#成功# 代表请求已经被服务器接收、理解、并接受 200 OK：请求成功(其后是对 GET 和 POST 请求的应答文档。) 201 Created — 请求被创建完成，同时新的资源被创建。 202 Accepted — 供处理的请求已被接受，但是处理未完成。 203 Non-authoritative Information — 文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝。 204 No Content — 没有新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而 Servlet 可以确定用户文档足够新，这个状态代码是很有用的。 205 Reset Content — 没有新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。 206 Partial Content — 客户发送了一个带有 Range 头的 GET 请求，服务器完成了它。 207 Multi-Status — 由 WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个 XML 消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。3xx: #重定向# 代表客户端需要采取进一步的操作才能完成请求 300 Multiple Choices — 多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。 301 Moved Permanently — 所请求的页面已经转移至新的 url。 302 Found — 所请求的页面已经临时转移至新的 url。 303 See Other — 所请求的页面可在别的 url 下被找到。 304 Not Modified — 未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求(一般是提供 If-Modified-Since 头表示客户只想比指定日期更新的文档)。服务器告诉客户，原来缓冲的文档还可以继续使用。 305 Use Proxy — 客户请求的文档应该通过 Location 头所指明的代理服务器提取。 306 Unused — 此代码被用于前一版本。目前已不再使用，但是代码依然被保留。 307 Temporary Redirect — 被请求的页面已经临时移至新的 url。4xx：#客户端错误# 代表客户端可能发生了错误，阻碍了服务器的处理， 400 Bad Request — 服务器未能理解请求或是请求参数有误。 401 Unauthorized — 被请求的页面需要用户名和密码。 402 Payment Required — 此代码尚无法使用(为了将来可能的需求而预留的。) 403 Forbidden — 对被请求页面的访问被禁止。 404 Not Found — 服务器无法找到被请求的页面。 405 Method Not Allowed — 请求中指定的方法不被允许。 406 Not Acceptable — 服务器生成的响应无法被客户端所接受。 407 Proxy Authentication Required — 用户必须首先使用代理服务器进行验证，这样请求才会被处理。 408 Request Timeout — 请求超出了服务器的等待时间。 409 Conflict — 由于冲突，请求无法被完成。 410 Gone — 被请求的页面不可用。 411 Length Required”Content-Length — “ 未被定义。如果无此内容，服务器不会接受请求。 412 Precondition Failed — 请求中的前提条件被服务器评估为失败。 413 Request Entity Too Large — 由于所请求的实体的太大，服务器不会接受请求。 414 Request-url Too Long — 由于 url 太长，服务器不会接受请求。当 post 请求被转换为带有很长的查询信息的 get 请求时，就会发生这种情况。 415 Unsupported Media Type — 由于媒介类型不被支持，服务器不会接受请求。 416 — 服务器不能满足客户在请求中指定的 Range 头。 417 Expectation Failed5xx： #服务器错误# 代表服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。 500 Internal Server Error — 请求未完成。服务器遇到不可预知的情况。 501 Not Implemented — 请求未完成。服务器不支持所请求的功能。 502 Bad Gateway — 请求未完成。服务器从上游服务器收到一个无效的响应。 503 Service Unavailable — 请求未完成。服务器临时过载或当机。 504 Gateway Timeout — 网关超时。 505 HTTP Version Not Supported — 服务器不支持请求中指明的 HTTP 协议版本。 HTTP1.1 与 HTTP1.1 的区别(Key Differences between HTTP&#x2F;1.0 and HTTP&#x2F;1.1)最大的区别：HTTP1.0 规定浏览器与服务器只保持短暂的链接，每次请求需要建立 TCP 连接，完成后立即断开；HTTP1.1 支持持久连接，一个连接可用于多次响应请求交换，允许客户端不用等待上一次结果返回，就可以发送下一个请求。 总结：博客要坚持写，小问题也可以写写。","categories":[{"name":"Font-end","slug":"Font-end","permalink":"https://jiangjingscom.github.io/categories/Font-end/"}],"tags":[]},{"title":"去掉jQuery","date":"2017-04-01T07:59:49.000Z","path":"2017/04/01/20170401/","text":"一直在Angular中混用jQuery，用来操作DOM，因为它(wo)很(tai)方(nian)便(qing)，最近将jQuery从项目中移除了，将所有涉及到jQuery操作换为用angular提供的api或原生js来实现……虽然jQuery压缩过才100kb左右。1.Angular内置jqLite，封装了部分操作DOM的api，使用angular.element(ele)相当于jQuery中的$,具体使用见官方文档。因此我们所使用的jQuery选择器，例如： 1$(&quot;#empl-name&quot;).val(); 可以换成： 1angular.element(document.querySelector(&quot;#empl-name&quot;)); 使用document.querySelector 的原因官方文档中有说明: 2.替换掉依赖jQuery的插件。例如，使用的jQuery的tooltip组件插件，现在换成ui bootstrap中的tooltip组件。原来引入jQuery tooltip插件代码后，封装成指令： 123456789101112131415161718192021222324&quot;use strict&quot;;var moduleName=&quot;kass.widget.tooltip&quot;;angular.module(moduleName,[]).directive(&quot;tooltip&quot;,[function()&#123; return&#123; restrict : &quot;A&quot;, link : function(scope, element, attrs)&#123;//element:指令标签对象 attrs:指令属性 var opts =&#123; //将带有tooltip属性的&quot;Target element&quot;传给插件创建tooltip formatter: function(scope)&#123; return scope.$target.attr(&quot;tooltip&quot;);//$target是利用$(this)封装的jquery对象 &#125;, //插件提供的tooltip属性值direction与指令属性tooltipDirection direction : attrs.tooltipDirection ? attrs.tooltipDirection : &quot;bottom&quot; &#125;; //插件提供的tipper方法设置tooltip属性值 element.tipper(opts); element.one(&quot;$destroy&quot;,function()&#123; element.tipper(&quot;destroy&quot;); &#125;); &#125; &#125;&#125;]);module.exports=moduleName; 引入ui bootstrap 中的tooptip部分： 12345678910111213141516require(&quot;./position&quot;);//ui bootstrap的position部分require(&quot;./stackedMap&quot;);//ui bootstrap的stackedMap部分angular.module(&#x27;ui.bootstrap.tooltip&#x27;, [&#x27;ui.bootstrap.position&#x27;, &#x27;ui.bootstrap.stackedMap&#x27;,&quot;uib/template/tooltip/tooltip-html-popup.html&quot;,&quot;uib/template/tooltip/tooltip-popup.html&quot;,&quot;uib/template/tooltip/tooltip-template-popup.html&quot;]) .provider(&#x27;$uibTooltip&#x27;, function()&#123;........&#125;).......directive(&#x27;uibTooltipTemplatePopup&#x27;, function() &#123; return &#123; restrict: &#x27;A&#x27;, scope: &#123; contentExp: &#x27;&amp;&#x27;, originScope: &#x27;&amp;&#x27; &#125;, templateUrl: &#x27;uib/template/tooltip/tooltip-template-popup.html&#x27; &#125;;&#125;);......angular.module(&quot;uib/template/tooltip/tooltip-popup.html&quot;, []).run(......);......angular.module(&#x27;ui.bootstrap.tooltip&#x27;).run(......); 发现github上的一个封装angular tooltip的项目,使用方便有demo,⊙o⊙…… 3.jQuery的动画部分。一些动画可以直接使用css的animation、transition属性进行设置，还可以使用angular提供的动画。例如jQuery一个简单的改变位置动画，需要在动画完成后移除这个指令组件： 12345$(&quot;.side-modal&quot;).animate(&#123;right:&#x27;-100%&#x27;&#125;,300,function()&#123; $scope.$apply(function()&#123; $scope.onRemove(); &#125;);&#125;); 使用angular的动画，要引入angular-animate.js文件，注入ngAnimate： 123456789101112131415161718192021222324&quot;use strict&quot;;require(&quot;./angular-animte-min&quot;);var moduleName = &quot;animateTest&quot;;angular.module(moduleName,[&quot;ngAnimate&quot;]).directive(myTest,[&quot;$animate&quot;,function(&quot;$animate&quot;)&#123; return&#123; restrict : &quot;AE&quot;, replace : false, scope : &#123; onRemove : &quot;&amp;&quot; &#125;, template : require(&quot;html!../template/to/mytest.html&quot;), controller : [&quot;$scope&quot;,function($scope)&#123; ...... var slideBox = angular.element(document.querySelector(&quot;.side-modal&quot;)); $animate.addClass(slideBox,&#x27;set-right&#x27;,function()&#123; $scope.onRemove();//callback,动画完成后移除指令 &#125;); ...... &#125;], link:function(scope,element,attrs)&#123;......&#125; &#125;&#125;]);module.exports=moduleName; 4.其他部分可以参考github上的一个项目：You Don’t Need jQuery。 April Fool’s Day ….⊙o⊙….","categories":[{"name":"Font-end","slug":"Font-end","permalink":"https://jiangjingscom.github.io/categories/Font-end/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jiangjingscom.github.io/tags/JavaScript/"}]},{"title":"从零到gulp","date":"2017-03-18T09:13:27.000Z","path":"2017/03/18/20170318/","text":"本菜刚开始写前端页面，目录是这样的，js 放一起，html 放一起：然后，我开始学 nwjs 啦，多了一个 package.json 文件（plugins 打算用来放插件，是空的；.log 文件打算用 node 的 file 模块写入日志），之后本菜默默开始写登录小窗，菜单，托盘，然后…写完 demo 明白自己很菜开始好好学 js。 开始刷书，刷博客，刷代码，看小伙伴们的代码…于是我开始写简单页面啦，开始用 jquery（获取和操作 DOM 元素，写 ajax 请求），angularjs，最初目录是这样：开始安装 node，利用 npm 管理模块，学着小伙伴用 webpack，一个入口 index.js 文件，功能分开写再打包成一个 js 文件；装 fis3，更改代码可以自动刷新页面，目录变成这样：开始好好学 angularjs，路由，数据绑定，指令，师傅组装的 ui 组件…发现自己真的菜，好多知识要学，嗯！舍弃 fis3（文件多了，release 变慢，-wL 要等好久），用 http-server，目录变成这样：然后，发现 gulp,新大陆！添加一个 gulpfile.js 文件，用 gulp-connect 创建 web 服务器；可以 watch 页面，gulp-livereload 自动刷新；嵌入原来的 webpack.config.js 还能继续打包；只用运行一个 gulp，开心！ 某一天，我发现我的 cpu 原来是这样：开了 gulp 之后，变成这样： ……… 我想这一定是我的错！ ……… 最后发现用 gulp 来 watch 时一定不要加很多文件啊！只 watch 经常改变的。不然电脑变得超级卡，还以为自己一脚把主机踢坏了(⊙v⊙)…..就酱！ 感谢师傅！ —-2017-4-30 更新—-gulp + webpack2，附上 gulpfile.js 的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980var gulp = require(&quot;gulp&quot;), gutil = require(&quot;gulp-util&quot;), clean = require(&quot;gulp-clean&quot;), concat = require(&quot;gulp-concat&quot;), cssmin = require(&quot;gulp-cssmin&quot;), connect = require(&quot;gulp-connect&quot;), livereload = require(&quot;gulp-livereload&quot;), webpack = require(&quot;webpack&quot;), webpackConfig = require(&quot;./webpack.config.js&quot;);//创建连接gulp.task(&quot;connect&quot;, function () &#123; connect.server(&#123; root: &quot;./&quot;, ip: &quot;192.168.1.77&quot;, port: 8080, livereload: true, &#125;);&#125;);//图片和iconfont到拷贝到assetsgulp.task(&quot;copy:images&quot;, function (done) &#123; gulp .src([&quot;./admin/static/img/**/*&quot;]) .pipe(gulp.dest(&quot;./admin/assets/img&quot;)) .on(&quot;end&quot;, done); gulp .src([&quot;./admin/static/font/*&quot;]) .pipe(gulp.dest(&quot;./admin/assets/font&quot;)) .on(&quot;end&quot;, done);&#125;);//合并压缩css到assetsgulp.task(&quot;min:css&quot;, function (done) &#123; gulp .src([&quot;./admin/static/css/*.css&quot;]) .pipe(concat(&quot;./style.min.css&quot;)) .pipe(cssmin()) .pipe(gulp.dest(&quot;./admin/assets/css/&quot;)) .on(&quot;end&quot;, done);&#125;);//监听文件变化gulp.task(&quot;watch&quot;, function (done) &#123; livereload.listen(); gulp .watch(&quot;./admin/assets/**/*&quot;, [&quot;build-admin&quot;], function (file) &#123; livereload.changed(file.path); &#125;) .on(&quot;end&quot;, done);&#125;);//webpack打包var myDevConfig = Object.create(webpackConfig);var devCompiler = webpack(myDevConfig);gulp.task(&quot;build-admin&quot;, function (callback) &#123; devCompiler.run(function (err, stats) &#123; if (err) throw new gutil.PluginError(&quot;webpack:build-admin&quot;, err); gutil.log( &quot;[webpack:build-admin]&quot;, stats.toString(&#123; colors: true, &#125;) ); callback(); &#125;);&#125;);//build之前cleangulp.task(&quot;clean&quot;, function (done) &#123; gulp.src([&quot;admin/assets&quot;]).pipe(clean()).on(&quot;end&quot;, done);&#125;);gulp.task(&quot;default&quot;, [ &quot;connect&quot;, &quot;copy:images&quot;, &quot;min:css&quot;, &quot;watch&quot;, &quot;build-admin&quot;,]);","categories":[{"name":"Font-end","slug":"Font-end","permalink":"https://jiangjingscom.github.io/categories/Font-end/"}],"tags":[]},{"title":"git学习记录","date":"2017-03-17T09:09:02.000Z","path":"2017/03/17/20170317/","text":"公司一直用的是svn（集中式版本控制系统 ），一般日常提交代码用update（从中央服务器上获取最新代码）和commit（将本地代码提交上去，提交前会用Beyond Compare软件对比修改一下）两个命令就能满足一般需求，偶尔会看一下日志，用一下版本回滚。但是最近搭博客，开始使用 github，了解到git（分布式版本控制系统）好像很火？大家都在推荐，于是用了一下这个新工具。 首先，如果你想详细了解 git 原理和使用，狠狠点击这里！此外，还有很多关于 git 不同风格的博客啊，比如廖雪峰写的 git 教程。但是，如果你口味清奇有趣，可以选择这个，敲生动，适合食用！ 然后，列一下学习记录： 先学点简单的： 1.网上下载安装 git，得到大礼包：Git Bash，Git GUI，Git CMD，一般操作使用Git Bash即可。 2.本地新建文件，使用git init将它变成待用仓库。 3.获取代码： 1git clone &lt;server url&gt; //将远程仓库 上的代码拉到仓库中。 4.修改代码后，这样提交它： 1git add &lt;filename&gt; //提交 到缓存区（index） 或者使用： 1git add . //提交 所有改动文件到缓存区 再将其提交到本地仓库中： 1git commit -m &quot;修改信息&quot; //提交到本地仓库中的HEAD上 期间，你可以用git status查看文件变化。 下图是我修改 blog 中的文件时，git status返回的文件状态 1git push origin master //提交到远程仓库origin 如果你没有进行第 3 步，这里使用： 1git remote add origin &lt;server url&gt; //提交到远程仓库 5.我们经常要将远程仓库中的代码更新本地： 1git pull 满足基本的需求后，我们了解一下 git 的分支功能： 1.创建、查看、切换分支： 1234git branch newbranch //新建一个名newbranch的分支 git checkout -b newbranch //新建一个名newbranch的分支并切换到新分支 git branch //查看分支 git checkout master //回到主分支master 然后就可以在确定的分支下操作（比如上方的基础操作）。 2.进行分支间的操作，比如： 12git branch -d newbranch //删除这个分支 git merge &lt;branchname&gt; //合并分支到当前分支 来一张 learngitbranch 的图： 此时可能产生冲突，用git status查看情况，再去文件修改解决冲突，用git add 将冲突的文件标记为解决，再用git status确认冲突被解决，然后我们就可以用git commit提交了。 当然除了分支，git 还有很多功能（标签，撤销操作，版本回退），当有其他情况可以去查找命令，以上。","categories":[{"name":"Font-end","slug":"Font-end","permalink":"https://jiangjingscom.github.io/categories/Font-end/"}],"tags":[]},{"title":"WPF笔记","date":"2017-03-03T10:41:51.000Z","path":"2017/03/03/20170303/","text":"改写窗体：1.WPF 中使用默认窗口框架的外观，可以更改属性：(参考)Icon: 指定窗口的图标；Title: 指定窗口的标题；WindowStyle: 指定窗口样式，有 4 个取值： None，无边框；（当 ResizeMode 属性为 NoResize 时，仅剩下窗口核心。） SingleBorderWindow，单边框【默认】； ThreeDBorderWindow，3D 边框； ToolBorderWindow，工具箱窗口； ResizeMode 是指定大小调节样式，有 4 个取值： NoResize，不可调节，同时没有最大最小按钮； CanMinimize，不可调节。但可以最小化；（此时最大化按钮不可用） CanResize，可调节【默认】； CanResizeWithGrid，可根据网格调节；（窗口右下脚显示可调节网格） WindowStartLocation 指定窗口初始位置，有 3 个取值： Manual，手工指定位置，表示可以通过设置其 Top、Left 属性值来决定窗口的初始位置； CenterScreen，屏幕中央； CenterOwner，父窗体中央； 另外： MaxWidth、MinWidth、MaxHeight、MinHeight ：表示窗口最大宽度、最小宽度、最大高度、最小高度。可以通过得到和更改这些属性值，来获取和改变窗口的大小和长宽范围。 TitlebarHeight&#x3D;”45” &#x2F;&#x2F;修改窗体 titlebar 高度； AllowsTransparency：获取或设置一个值，该值指示窗口的工作区是否支持透明； 2.设置窗体无边框：设置 WindowStyle&#x3D;”None”、 AllowsTransparency&#x3D;”True” 即可。_如下_： 12345678910&lt;Window x:Class=&quot;WpfApplication1.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; Title=&quot;MainWindow&quot; Height=&quot;350&quot; Width=&quot;525&quot; WindowStyle=&quot;None&quot; AllowsTransparency=&quot;True&quot;&gt; &lt;Grid&gt; &lt;/Grid&gt;&lt;/Window&gt; 3.窗口拖放： 123private void Window_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)&#123; this.DragMove();&#125; 调用： 1this.MouseLeftButtonDown += delegate &#123; DragMove(); &#125;; 或： 123456MouseDown=&quot;Window_MouseDown&quot;private void Window_MouseDown(object sender, MouseButtonEventArgs e)&#123; if (e.LeftButton == MouseButtonState.Pressed)&#123; DragMove(); &#125;&#125; 4.自定义窗体最大化、最小化、关闭如下： 12345678910111213private void btn_min_Click(object sender, RoutedEventArgs e)&#123; this.WindowState = WindowState.Minimized;&#125;private void btn_max_Click(object sender, RoutedEventArgs e)&#123; if(this.WindowState == WindowState.Maximized)&#123; this.WindowState = WindowState.Normal; //还原 &#125;else&#123; this.WindowState = WindowState.Maximized; &#125;&#125;private void btn_close_Click(object sender, RoutedEventArgs e)&#123; this.Close();&#125; 5.窗口阴影：(WPF4.5) 1234567891011121314151617&lt;Window x:Class=&quot;WPFTest.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; Title=&quot;MainWindow&quot; Width=&quot;525&quot; Height=&quot;350&quot;&gt; &lt;WindowChrome.WindowChrome&gt; &lt;WindowChrome CaptionHeight=&quot;30&quot; CornerRadius=&quot;0&quot; GlassFrameThickness=&quot;1&quot; NonClientFrameEdges=&quot;None&quot; ResizeBorderThickness=&quot;5&quot; UseAeroCaptionButtons=&quot;False&quot; /&gt; &lt;/WindowChrome&gt; &lt;Grid&gt; &lt;/Grid&gt;&lt;/Window&gt; tooltip给某个空间增加 tooltip 显示详细信息: 1234567private void Tip_MouseMove(object sender, MouseEventArgs e)&#123; ListViewItem listitem = (sender as Image).TryFindParent&lt;ListViewItem&gt;(); FDObject item = (FDObject)listitem.DataContext; if (item != null)&#123; (sender as Image).ToolTip = item.path; &#125;&#125; 直接用 control.Tooltip&#x3D;text; 在鼠标移入事件中确定 System.Drawing.Image 对象System.Drawing.Image 和 System.Windows.Media.ImageSource 之间转换例： 123456789MemoryStream ms = new MemoryStream ();var bitmap = new BitmapImage();bitmap.BeginInit();userImage.Save (ms,System.Drawing.Imaging. ImageFormat.Bmp);ms.Seek(0, SeekOrigin.Begin);bitmap.StreamSource = ms;bitmap.EndInit();emplImage.Source = bitmap;return emplImage; 旋转动画：例： 123456789101112 private void Button_Click(object sender, RoutedEventArgs e)&#123; RotateTransform a = new RotateTransform(); Refresh.RenderTransform = a; Refresh.RenderTransformOrigin = new Point(0.5, 0.5); DoubleAnimation myDouble = new DoubleAnimation(0, 360, new Duration(TimeSpan.FromSeconds(1))); Storyboard story = new Storyboard(); myDouble.RepeatBehavior = RepeatBehavior.Forever; story.Children.Add(myDouble); Storyboard.SetTarget(myDouble, Refresh); Storyboard.SetTargetProperty(myDouble, new PropertyPath(&quot;RenderTransform.Angle&quot;)); story.Begin();&#125; 12345&lt;Grid&gt; &lt;TextBlock x:Name=&quot;Refresh&quot; VerticalAlignment=&quot;Center&quot; HorizontalAlignment=&quot;Center&quot; Text=&quot;&amp;#xe712;&quot; /&gt; &lt;Button VerticalAlignment=&quot;Bottom&quot; HorizontalAlignment=&quot;Center&quot; Width=&quot;100&quot; Height=&quot;50&quot; Click=&quot;Button_Click&quot;/&gt;&lt;/Grid&gt;","categories":[{"name":"Others","slug":"Others","permalink":"https://jiangjingscom.github.io/categories/Others/"}],"tags":[{"name":"Program","slug":"Program","permalink":"https://jiangjingscom.github.io/tags/Program/"}]},{"title":"JS对字符串操作","date":"2017-03-02T10:44:08.000Z","path":"2017/03/02/20170302/","text":"截取字符串：1.split： 把一个字符串分割成字符串数组。 功能 ：使用一个指定的分隔符把字符串分隔存储到数组语法 ：str.split(separator,size)参数 ： str：必选项。要截取的字符串。 separator: 必选项。要分割的条件，是字符串或表达式。 size：可选项。返回数组的长度。不定义则全部返回。 实例 ： 1var str=”jpg|bmp|gif|ico|png”; arr=str.split(”|”);//arr是一个包含字符值”jpg”、”bmp”、”gif”、”ico”和”png”的数组 2.slice： 提取字符串的某个部分。 功能：返回一个新的数组，包含从start到end（不包括该元素）的arrayobject中的元素。语法：str.slice(startPos,endPos)参数： startPos: 必选项。字符串的起始位置。如果参数负数，则从字符串的结尾处算起。 也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。 endPos: 可选项。提取字符串的结束小标。 如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。 实例： 12var str=&#x27;ahji3o3s4e6p8a0sdewqdasj&#x27;alert(str.slice(2,5)) //结果ji3 3.substring： 返回指定位置的子字符串。 功能：用于提取字符串中介于两个指定下标之间的字符。语法：str.substring(startPos,endPos)参数： str: 必选项。要提取的字符串。 startPos: 必选项。子字符串的起始位置，该索引从0开始计算。 一个非负的整数，规定要提取的子串的第一个字符在 stringObject 中的位置。 endPos: 可选项。子字符串的结束位置，该索引从0开始计算。 一个非负的整数，比要提取的子串的最后一个字符在 stringObject 中的位置多 1。 如果省略该参数，那么返回的子串会一直到字符串的结尾。 注： 返回 一个新的字符串，该字符串值包含 stringObject 的一个子字符串，其内容是从 start 处到 stop-1 处的所有字符，其长度为 stop 减 start。 说明 substring 方法返回的子串包括 start 处的字符，但不包括 end 处的字符。 如果 start 与 end 相等，那么该方法返回的就是一个空串（即长度为 0 的字符串）。 如果 start 比 end 大，那么该方法在提取子串之前会先交换这两个参数。 如果 start 或 end 为负数，那么它将被替换为 0。 实例： 12str=&#x27;ahji3o3s4e6p8a0sdewqdasj&#x27;alert(str.substring(2,6)) //结果为ji3o3 4.substr: 返回字符串中指定位置开始的指定长度的子字符串。 语法：str.substr(startPos,length)参数： str：必选项。要提取的字符串。 startPos: 必选项。返回字符串的起始位置，单位为数字。 字符串中的第一个字符的索引为 0。为负数，则默认为0 length: 可选项。返回字符串的字符个数。 说明 如果 length 为 0 或负数，将返回一个空字符串。 如果没有指定该参数，则子字符串将延续到stringObject的最后。 实例： 123456var str = &quot;0123456789&quot;;alert(str.substring(5)); //&quot;56789&quot;alert(str.substring(10)); //&quot;&quot;alert(str.substring(2,12)); //&quot;23456789&quot;alert(str.substring(2,-2)); //&quot;01&quot;alert(str.substring(-1,5)); //&quot;01234&quot; 合并字符串1.join 功能：使用您选择的分隔符将一个数组合并为一个字符串。 实例： 123var delimitedString=myArray.join(delimiter);var myList=new Array(”jpg”,”bmp”,”gif”,”ico”,”png”);var portableList=myList.join(”|”);//结果是jpg|bmp|gif|ico|png 2.concat 功能：将两个数组连接在一起。 实例： 123arr1=[1,2,3,4]arr2=[5,6,7,8]alert(arr1.concat(arr2)) //结果为[1,2,3,4,5,6,7,8] 其他：1.charAt 功能：返回指定位置的字符。字符串中第一个字符的下标是 0。如果参数 index 不在 0 与 string.length 之间，该方法将返回一个空字符串。 实例: 12var str=&#x27;a,g,i,d,o,v,w,d,k,p&#x27;alert(str.charAt(2)) //结果为g 2.charCodeAt 功能：charCodeAt() 方法可返回指定位置的字符的Unicode 编码。这个返回值是 0 - 65535 之间的整数。方法 charCodeAt() 与 charAt() 方法执行的操作相似，只不过前者返回的是位于指定位置的字符的编码，而后者返回的是字符子串。 实例： 12var str=&#x27;a,g,i,d,o,v,w,d,k,p&#x27;alert(str.charCodeAt(2)) //结果为103。即g的Unicode编码为103 3.replace: 用于在字符串中用一些字符替换另一些字符。 语法：str.replace(string,replacement)参数： str：必选项。要替换的字符串。 string:必选项。正则对象。 replacement: 必选项。要替换的字符。 —-记录这些是因为某些时候会记错某个方法返回结果，基本用法还是要记一记的，羞愧&#x3D; &#x3D;—-","categories":[{"name":"Font-end","slug":"Font-end","permalink":"https://jiangjingscom.github.io/categories/Font-end/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jiangjingscom.github.io/tags/JavaScript/"}]},{"title":"my first blog","date":"2017-03-01T08:40:04.000Z","path":"2017/03/01/20170301/","text":"博客由 hexo+github 搭建，遵循 markdown 语法来编辑博客，网上教程很多，比较简单。博客内容来自于印象笔记，从我的小本本上选一些搬出来，(⊙v⊙)嗯！","categories":[{"name":"Others","slug":"Others","permalink":"https://jiangjingscom.github.io/categories/Others/"}],"tags":[]}]